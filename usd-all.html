

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Universal Stanford Dependencies</title>
    <link rel="stylesheet" type="text/css" href="css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <link rel="stylesheet" type="text/css" href="http://weaver.nlplab.org/~brat/demo/v1.3/style-vis.css"/>
    <script type="text/javascript" src="http://weaver.nlplab.org/~brat/demo/v1.3/client/lib/head.load.min.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->
  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
          <span class="header-text"><a href="http://universaldependencies.github.io/docs/">home</a></span>

      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          
<h2 id="advcl-adverbial-clause-modifier">advcl: adverbial clause modifier</h2>

<p>An adverbial clause modifier of a VP or S is a clause modifying the
verb (temporal clause, consequence, conditional clause, purpose
clause, etc.).</p>

<div class="sd-parse">
  <p>The accident happened as the night was falling
advcl(happened, falling)</p>
</div>

<div class="sd-parse">
  <p>If you know who did it , you should tell the teacher
advcl(tell, know)</p>
</div>

<div class="sd-parse">
  <p>He talked to him in order to secure the account
advcl(talked, secure)</p>
</div>

<h2 id="advmod-adverbial-modifier">advmod: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) adverb or adverbial
phrase (ADVP) that serves to modify the meaning of the word.</p>

<div class="sd-parse">
  <p>Genetically modified food
advmod(modified, Genetically)</p>
</div>

<div class="sd-parse">
  <p>less often
advmod(often, less)</p>
</div>

<h2 id="amod-adjectival-modifier">amod: adjectival modifier</h2>

<p>An adjectival modifier of an NP is any adjectival phrase that serves
to modify the meaning of the NP.</p>

<div class="sd-parse">
  <p>Sam eats red meat
amod(meat, red)</p>
</div>

<div class="sd-parse">
  <p>Sam took out  a 3 million dollar loan
amod(loan, dollar)</p>
</div>

<div class="sd-parse">
  <p>Sam took out  a $ 3 million loan
amod(loan, $)</p>
</div>

<h2 id="appos-appositional-modifier">appos: appositional modifier</h2>

<p>An appositional modifier of an NP is an NP immediately to the right of
the first NP that serves to define or modify that NP. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.</p>

<div class="sd-parse">
  <p>Sam , my brother , arrived
appos(Sam-1, brother-4)</p>
</div>

<div class="sd-parse">
  <p>Bill ( John &#8216;s cousin )
appos(Bill-1, cousin-5)</p>
</div>

<div class="sd-parse">
  <p>The Australian Broadcasting Corporation ( ABC )
appos(Corporation-4, ABC-6)</p>
</div>

<h2 id="aux-auxiliary">aux: auxiliary</h2>

<p>An auxiliary of a clause is a non-main verb of the clause, e.g., a
modal auxiliary, or a form of &#8220;be&#8221;, &#8220;do&#8221; or &#8220;have&#8221; in a periphrastic
tense.</p>

<div class="sd-parse">
  <p>Reagan has died
aux(died-3, has-2)</p>
</div>

<div class="sd-parse">
  <p>He should leave
aux(leave-3, should-2)</p>
</div>

<h2 id="auxpass-passive-auxiliary">auxpass: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a non-main verb of the clause which
contains the passive information.</p>

<div class="sd-parse">
  <p>Kennedy has been killed
auxpass(killed, been)</p>
</div>

<div class="sd-parse">
  <p>Kennedy was killed
auxpass(killed, was)</p>
</div>

<div class="sd-parse">
  <p>Kennedy got killed
auxpass(killed, got)</p>
</div>

<h2 id="case-todo">case: TODO</h2>

<h2 id="cc-coordination">cc: coordination</h2>

<p>A coordination is the relation between an element of a conjunct and
the coordinating conjunction word of the conjunct.  (Note: different
dependency grammars have different treatments of coordination.  We
take one conjunct of a conjunction (normally the first) as the head of
the conjunction.) A conjunction may also appear at the beginning of a
sentence.  This is also called a cc, and dependent on the root
predicate of the sentence.</p>

<div class="sd-parse">
  <p>And then we left .
cc(left, And)</p>
</div>

<h2 id="ccomp-clausal-complement">ccomp: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause with
an internal subject which functions like an object of the verb, or
adjective.  Clausal complements for nouns are limited to complement
clauses with a subset of nouns like &#8220;fact&#8221; or &#8220;report&#8221;.  We analyze
them the same (parallel to the analysis of this class as &#8220;content
clauses&#8221; in Huddleston and Pullum 2002). Such clausal complements are
usually finite (though there are occasional remnant English
subjunctives).</p>

<div class="sd-parse">
  <p>He says that you like to swim
ccomp(says, like)</p>
</div>

<h2 id="compound-todo">compound: TODO</h2>

<h2 id="conj-conjunct">conj: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as &#8220;and&#8221;, &#8220;or&#8221;, etc.  We treat
conjunctions asymmetrically: The head of the relation is the first
conjunct and other conjunctions depend on it via the <em>conj</em> relation.</p>

<div class="sd-parse">
  <p>Bill is big and honest
conj(big, honest)</p>
</div>

<h2 id="cop-copula">cop: copula</h2>

<p>A copula is the relation between the complement of a copular verb and
the copular verb.  (We normally take a copula as a dependent of its
complement; see the discussion in section~\ref{types}.)</p>

<div class="sd-parse">
  <p>Bill is an honest man
cop(man, is)</p>
</div>

<h2 id="csubj-clausal-subject">csubj: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. In the two following
examples, &#8220;what she said&#8221; is the subject.</p>

<div class="sd-parse">
  <p>What she said makes sense
csubj(makes, said)</p>
</div>

<h2 id="csubjpass-clausal-passive-subject">csubjpass: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive
clause. In the example below, &#8220;that she lied&#8221; is the subject.</p>

<div class="sd-parse">
  <p>That she lied was suspected by everyone
csubjpass(suspected, lied)</p>
</div>

<h2 id="dep-unspecified-dependency">dep: unspecified dependency</h2>

<p>A dependency is labeled as <em>dep</em> when the system is unable to
determine a more precise dependency relation between two words.  This
may be because of a weird grammatical construction, a limitation in
the Stanford Dependency conversion software, a parser error, or
because of an unresolved long distance dependency.</p>

<div class="sd-parse">
  <p>Then , as if to show that he could , \ldots
dep(show, if)</p>
</div>

<h2 id="det-determiner">det: determiner</h2>

<p>A determiner is the relation between the head of an NP and its
determiner.</p>

<div class="sd-parse">
  <p>The man is here
det(man, The)</p>
</div>

<div class="sd-parse">
  <p>Which book do you prefer ?
det(book, Which)</p>
</div>

<h2 id="discourse-discourse-element">discourse: discourse element</h2>

<p>This is used for interjections and other discourse particles and
elements (which are not clearly linked to the structure of the
sentence, except in an expressive way). We generally follow the
guidelines of what the Penn Treebanks count as an INTJ.  They define
this to include: interjections (<em>oh</em>, <em>uh-huh</em>, <em>Welcome</em>), fillers
(<em>um</em>, <em>ah</em>), and discourse markers (<em>well</em>, <em>like</em>, <em>actually</em>, but
not <em>you know</em>).</p>

<div class="sd-parse">
  <p>Iguazu is in Argentina :)
discourse(is-2, :)-5)</p>
</div>

<h2 id="dislocated-todo">dislocated: TODO</h2>

<h2 id="dobj-direct-object">dobj: direct object</h2>

<p>The direct object of a VP is the noun phrase which is the (accusative)
object of the verb.</p>

<div class="sd-parse">
  <p>She gave me a raise
dobj(gave, raise)</p>
</div>

<h2 id="expl-expletive">expl: expletive</h2>

<p>This relation captures an existential &#8220;there&#8221;. The main verb of the
clause is the governor.</p>

<div class="sd-parse">
  <p>There is a ghost in the room
expl(is, There)</p>
</div>

<h2 id="foreign-todo">foreign: TODO</h2>

<h2 id="goeswith-goes-with">goeswith: goes with</h2>

<p>This relation links two parts of a word that are separated in text
that is not well edited. We follow the treebank: The GW part is the
dependent and the head is in some sense the &#8220;main&#8221; part, often the
second part.</p>

<div class="sd-parse">
  <p>They come here with out legal permission
goeswith(out-5, with-4)</p>
</div>

<h2 id="iobj-indirect-object">iobj: indirect object</h2>

<p>The indirect object of a VP is the noun phrase which is the (dative)
object of the verb.</p>

<div class="sd-parse">
  <p>She gave me a raise
iobj(gave, me)</p>
</div>

<h2 id="list-todo">list: TODO</h2>

<h2 id="mark-marker">mark: marker</h2>

<p>A marker is the word introducing a finite clause subordinate to
another clause. For a complement clause, this will typically be &#8220;that&#8221;
or &#8220;whether&#8221;. For an adverbial clause, the marker is typically a
preposition like &#8220;while&#8221; or &#8220;although&#8221;. The mark is a dependent of the
subordinate clause head.</p>

<div class="sd-parse">
  <p>Forces engaged in fighting after insurgents attacked
mark(attacked, after)</p>
</div>

<div class="sd-parse">
  <p>He says that you like to swim
mark(swim, that)</p>
</div>

<h2 id="mwe-multi-word-expression">mwe: multi-word expression</h2>

<p>The multi-word expression (modifier) relation is used for certain
multi-word idioms that behave like a single function word.  It is used
for a closed set of dependencies between words in common multi-word
expressions for which it seems difficult or unclear to assign any
other relationships.  At present, this relation is used inside the
following expressions: <em>rather than, as well as, instead of, such as,
because of, instead of, in addition to, all but, such as, because of,
instead of, due to</em>.  The boundaries of this class are unclear; it
could grow or shrink a little over time.</p>

<div class="sd-parse">
  <p>I like dogs as well as cats
mwe(well, as)</p>
</div>

<div class="sd-parse">
  <p>He cried because of you
mwe(of, because)</p>
</div>

<h2 id="name-todo">name: TODO</h2>

<h2 id="ncmod-nominalized-clause-modifier">ncmod: nominalized clause modifier</h2>

<p>TODO</p>

<h2 id="neg-negation-modifier">neg: negation modifier</h2>

<p>The negation modifier is the relation between a negation word and the
word it modifies.</p>

<div class="sd-parse">
  <p>Bill is not a scientist
neg(scientist, not)</p>
</div>

<div class="sd-parse">
  <p>Bill does n&#8217;t drive
neg(drive, n&#8217;t)</p>
</div>

<h2 id="nfincl-todo">nfincl: TODO</h2>

<h2 id="nmod-todo">nmod: TODO</h2>

<h2 id="nsubj-nominal-subject">nsubj: nominal subject</h2>

<p>A nominal subject is a noun phrase which is the syntactic subject of a
clause. The governor of this relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun.</p>

<div class="sd-parse">
  <p>Clinton defeated Dole
nsubj(defeated, Clinton)</p>
</div>

<h2 id="nsubjpass-passive-nominal-subject">nsubjpass: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.</p>

<div class="sd-parse">
  <p>Dole was defeated by Clinton
nsubjpass(defeated, Dole)</p>
</div>

<h2 id="nummod-numeric-modifier">nummod: numeric modifier</h2>

<p>A numeric modifier of a noun is any number phrase that serves to
modify the meaning of the noun with a quantity.</p>

<div class="sd-parse">
  <p>Sam ate 3 sheep
nummod(sheep, 3)</p>
</div>

<div class="sd-parse">
  <p>Sam spent forty dollars
nummod(dollars, forty)</p>
</div>

<div class="sd-parse">
  <p>Sam spent $ 40
nummod($, 40)</p>
</div>

<h2 id="parataxis-parataxis">parataxis: parataxis</h2>

<p>The parataxis relation (from Greek for &#8220;place side by side&#8221;) is a
relation between the main verb of a clause and other sentential
elements, such as a sentential parenthetical, a clause after a &#8220;:&#8221; or
a &#8220;;&#8221;, or two sentences placed side by side without any explicit
coordination or subordination.</p>

<div class="sd-parse">
  <p>The guy , John said , left early in the morning
parataxis(left, said)</p>
</div>

<div class="sd-parse">
  <p>Let &#8216;s face it we &#8216;re annoyed
parataxis(Let, annoyed)</p>
</div>

<h2 id="punct-punctuation">punct: punctuation</h2>

<p>This is used for any piece of punctuation in a clause, if punctuation
is being retained in the typed dependencies. By default, punctuation
is not retained in the output.</p>

<div class="sd-parse">
  <p>Go home !
punct(Go, !)</p>
</div>

<h2 id="relcl-relative-clause-modifier">relcl: relative clause modifier</h2>

<p>A relative clause modifier of an NP is a relative clause modifying the
NP.  The relation points from the head noun of the NP to the head of
the relative clause, normally a verb.</p>

<div class="sd-parse">
  <p>I saw the man you love
relcl(man, love)</p>
</div>

<h2 id="remnant-todo">remnant: TODO</h2>

<h2 id="reparandum-todo">reparandum: TODO</h2>

<h2 id="root-root">root: root</h2>

<p>The root grammatical relation points to the root of the sentence. A
fake node &#8220;ROOT&#8221; is used as the governor. The ROOT node is indexed
with &#8220;0&#8221;, since the indexation of real words in the sentence starts at
1.</p>

<div class="sd-parse">
  <p>ROOT I love French fries .
root(ROOT, love)</p>
</div>

<h2 id="vocative-todo">vocative: TODO</h2>

<h2 id="xcomp-open-clausal-complement">xcomp: open clausal complement</h2>

<p>An open clausal complement (<em>xcomp</em>) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the object of the next higher
clause, if there is one, or else by the subject of the next higher
clause. These complements are always non-finite, and they are
complements (arguments of the higher verb or adjective) rather than
adjuncts/modifiers, such as a purpose clause. The name <em>xcomp</em> is
borrowed from Lexical-Functional Grammar.</p>

<div class="sd-parse">
  <p>He says that you like to swim
xcomp(like, swim)</p>
</div>

<div class="sd-parse">
  <p>Sue asked George to respond to her offer
xcomp(asked, respond)</p>
</div>

<div class="sd-parse">
  <p>I consider him a fool
xcomp(consider, fool)</p>
</div>

<div class="sd-parse">
  <p>I consider him honest
xcomp(consider, honest)</p>
</div>



      </div>

<script type="text/javascript">
//    var bratLocation = 'http://weaver.nlplab.org/~brat/demo/v1.3';
    var bratLocation = 'http://weaver.nlplab.org/~brat/demo/master';
    head.js(
        // External libraries
        bratLocation + '/client/lib/jquery.min.js',
        bratLocation + '/client/lib/jquery.svg.min.js',
        bratLocation + '/client/lib/jquery.svgdom.min.js',
	bratLocation + '/client/lib/jquery-ui.min.js',

        // brat helper modules
        bratLocation + '/client/src/configuration.js',
        bratLocation + '/client/src/util.js',
        bratLocation + '/client/src/annotation_log.js',
        bratLocation + '/client/lib/webfont.js',
        // brat modules
        bratLocation + '/client/src/dispatcher.js',
        bratLocation + '/client/src/url_monitor.js',
        bratLocation + '/client/src/visualizer.js'
    );

    var webFontURLs = [
//        bratLocation + '/static/fonts/Astloch-Bold.ttf',
        bratLocation + '/static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        bratLocation + '/static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var collData = {
	'entity_types': [
// this is optional
        {
            'type': 'SPAN_DEFAULT',
            'bgColor': '#7fa2ff',
            'borderColor': 'darken'
        },
        {
            'type': 'token',
            'labels': [ '\u00A0\u00A0' ], // non-breaking space for empty
        }
	],
	'entity_attribute_types': [],
	'relation_types': [
// this is optional
//         {
//             'type': 'subj',
//             'labels': [ 'subj' ],
//             'dashArray': '3,3',
//             'color': 'green',
//             'args': [
//                 {
//                     'role': 'arg1',
//                     'targets': [ 'token' ]
//                 },
//                 {
//                     'role': 'arg2',
//                     'targets': [ 'token' ]
//                 }
//             ]
//         }
        ],
	'event_types': [],
    };

    var normalizeSpace = function(s) {
	s = s.replace(/^\s+/, '');
	s = s.replace(/\s+$/, '');
	s = s.replace(/\s\s+/g, ' ');
	return s;
    };

    var compactJSON = function(s) {
        // remove (some) space from JSON string, giving a visually
        // more compact (but equivalent and still pretty-printed)
        // version.

	// replace any space with ' ' in non-nested curly brackets
	s = s.replace(/(\{[^\{\}\[\]]*\})/g, 
		      function(a, b) { return b.replace(/\s+/g, ' '); });
	// replace any space with ' ' in [] up to nesting depth 1
// 	s = s.replace(/(\[(?:[^\[\]\{\}]|\[[^\[\]\{\}]*\])*\])/g, 
// 		      function(a, b) { return b.replace(/\s+/g, ' '); });
	// actually, up to nesting depth 2
	s = s.replace(/(\[(?:[^\[\]\{\}]|\[(?:[^\[\]\{\}]|\[[^\[\]\{\}]*\])*\])*\])/g, 
		      function(a, b) { return b.replace(/\s+/g, ' '); });
	return s
    };

    var ObjectToString = function(data) {
	return compactJSON(JSON.stringify(data, undefined, '    '));
    };

    var parseToken = function(token) {
	// return [text, POS] for token encoded as "text/POS", or
	// [text, "token"] if no POS (/-separated string) is included.
	var text, POS;

	m = token.match(/((?:[^\\]|\\.)+)\/(.+)$/);
	if (!m) {
	    text = token, POS = 'token';
	} else {
	    text = m[1], POS = m[2];
	}

	// apply defined backslash escape sequences
	text = text.replace(/((?:[^\\]+|\\.)*?)\\n/g, '$1\n');

	// unescape backslash escapes in text and tag
	text = text.replace(/([^\\]*)\\(.)/g, '$1$2');
	POS = POS.replace(/([^\\]*)\\(.)/g, '$1$2');

	return [text, POS];
    };

    // helper for *parse functions
    var makeLogger = function(logElement) {
        return function(s) {
	    if (logElement === undefined) {
		console.log(s);
	    } else {
		logElement.val(logElement.val() + s + '\n');
	    }
	};
    };

    // parse SD format, return brat document data format
    var sdParse = function(sd, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = sd.split('\n');

	// first line is assumed to be sentence text
	var sentence_text = lines[0];
	sentence_text = normalizeSpace(sentence_text);

	// determine token offsets and construct spans ("entities")
	var tokens = sentence_text.split(' '),
            spans = [],
            offset = 0,
            error = false;
	sentence_text = '';
	for (var i=0; i<tokens.length; i++) {
	    var text_POS = parseToken(tokens[i]);
	    var text = text_POS[0], POS = text_POS[1];
	    var length = text.length;
	    if (!text.match(/^\s*$/)) { // skip space-only (e.g. newline)
		spans.push(['T'+(i+1), POS, [[offset, offset+length]]]);
		tokens[i] = text;
	    }
	    offset += length + 1;
	    sentence_text += text + ' ';
	}

	var tokenIndex = function(t) {
	    // accept two formats: indexed ('dog-1') and simple ('dog')
	    // TODO: consider case-insensitive implementation

	    // indexed match
	    var m = t.match(/^\s*(.*)-(\d+)\s*$/)	      
	    if (m) {
		var text = m[1], idx = m[2];
		// confirm match (SD indices are 1-based)
		idx = parseInt(idx, 10) - 1;
		if (tokens[idx] === text) {
		    return idx;
		} else {
		    // TODO consider skipping output, not necessarily an error
		    log('token text mismatch: "'+text+'" vs. "'+tokens[idx]+'"');
		}
		// fall through to allow simple match for e.g. 'il-2'
	    }

	    // simple match
	    var firstIdx = $.inArray(t, tokens);
	    if (firstIdx === -1) {
		return null;
	    } else {
		if ($.inArray(t, tokens, firstIdx+1) !== -1) {
		    log('warning: multiple occurrences of "'+t+'"');
		}
		return firstIdx;
	    }
	};

	// parse lines after the first as dependencies, construct relations
	var relations = [];
	for (var i=1; i<lines.length; i++) {
	    var line = lines[i];
	    line = normalizeSpace(line);
	    
	    if (line.match(/^\s*$/)) {
		continue; // ignore empties
	    }
	    
	    var m = line.match(/^(\S+)\s*\(\s*(\S+)\s*,\s*(\S+)\s*\)$/);
	    if (!m) {
		log('failed to parse: "'+line+'"');
		error = true;
		continue;
	    }
	    var type = m[1], from = m[2], to = m[3];
	    
	    // determine which tokens are referred to
	    var fromIdx = tokenIndex(from), toIdx = tokenIndex(to);
	    if (fromIdx === null || toIdx === null) {
		log('failed to find token: "'+line+'"');
		error = true;
		continue;
	    }
	    
	    relations.push([ 'R'+i, type, [ [ 'arg1', 'T'+(fromIdx+1) ], 
					    [ 'arg2', 'T'+(toIdx+1)   ] ] ]);
	}

	log('SD parse done: '+spans.length+' tokens, '+relations.length+' dependencies.');
          
	return {
	    'text': sentence_text,
	    'entities' : spans,
            'relations' : relations,
	    'error' : error
	};
    };

    // parse CoNLL-X format, return brat document data format
    var conllXParse = function(conll, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = conll.split('\n');

        // each line has the following format
        // (from https://code.google.com/p/clearparser/wiki/DataFormat):
        //
        //     ID: token counter, starting at 1 for each new sentence
        //     FORM: word form or punctuation symbol
        //     LEMMA: lemma or stem of word form
        //     POSTAG: fine-grained part-of-speech tag
        //     FEATS: extra features ('_' indicates no extra feature)
        //     HEAD: head ID of the current token
        //     DEPREL: dependency relation to the HEAD
        // 
        // (here, we will use ID, FORM, POSTAG, HEAD and DEPREL)
        var ids = [],
            forms = [],
            postags = [],
            heads = [],
            deprels = [],
            error = false;
        for (var i=0; i<lines.length; i++) {
            var line = lines[i];
            line = line.replace(/\s$/, '');
            var fields = line.split(/\s+/);
            //var fields = line.split(/\t/);
            if (fields.length === 8) {
                ids.push(fields[0]);
                forms.push(fields[1]);
                postags.push(fields[4]);
                heads.push(fields[6]);
                deprels.push(fields[7]);
            } else {
                // TODO: better error handling
                log('expected 8 fields, got '+fields.length+': "'+line+'"');
		error = true;
		continue;
            }
        }

	var spans = [],
            relations = [],
            offset = 0;
	for (i=0; i<ids.length; i++) {
	    var length = forms[i].length;
	    spans.push(['T'+ids[i], postags[i], [[offset, offset+length]]]);
            offset += length + 1;
	    // TODO: handle root
	    if (heads[0] === 0) {
                continue;
	    }
            relations.push(['R'+ids[i], deprels[i], 
			    [ [ 'arg1', 'T'+heads[i] ],
			      [ 'arg2', 'T'+ids[i] ] ] ]);
        }

        var text = forms.join(' ');

	return {
	    'text': text,
	    'entities' : spans,
            'relations' : relations,
	    'error' : error
	};
    };

    var embeddedIdSeq = 1;

    var embedDependency = function(elem, parse, data, options) {
	// store sequence number for reference resolution
	elem.attr('embeddedSequenceNum', embeddedIdSeq);

	var eId = 'embedded-' + embeddedIdSeq++,
            inputTabId = eId + '-2',
            bratTabId = eId + '-3',
            infoTabId = eId + '-4';

	// visualization and related data elements
	var visDiv = $('<div id="'+eId+'-vis"></div>');
	var tabDiv = $('<div id="'+eId+'-tabs"></div>');
	var shDiv  = $('<div id="'+eId+'-sh" class="show-hide-div"></div>');
	var showHideButton = $('<button id="'+eId+'-toggle" '+
			       'class="show-hide-toggle">hide</button>');
	shDiv.append(showHideButton);

	var inputArea = $('<textarea id="'+eId+'-in" ' +
			  'class="embedded-brat-data"></textarea>');
	var bratArea = $('<textarea id="'+eId+'-brat" disabled="disabled" ' +
			 'class="embedded-brat-data"></textarea>');
	var logArea = $('<textarea id="'+eId+'-log" disabled="disabled" ' +
			'class="embedded-brat-data"></textarea>');

	// initialize parse function, falling back to SD as default
	if (parse === undefined) {
	    parse = sdParse;
	}

	// initialize data, defaulting to original element text
	if (data === undefined) {
	    data = elem.text();
	}
	data = normalizeSpace(data);
	var parsed = parse(data, makeLogger(logArea));
	inputArea.text(data);
	bratArea.text(ObjectToString(parsed));

        // initialize options, falling back to attributes as defaults
        if (options === undefined) {
            options = {};
        }
        $.each(elem[0].attributes, function(idx) {
            var name = this.name;
            var value = this.value;
            // ignore standard attributes and options provided by caller
            var standardAttr = ['id', 'class', 'embeddedsequencenum'];
            if ($.inArray(name.toLowerCase(), standardAttr) === -1 &&
                options[name] === undefined) {
                options[name] = value;
            }
	});
				      
	// build top-level structure
	elem.empty();
	// tab headers (li+a)
	tabDiv.append([
		       '<div id="'+eId+'">',
		       '  <ul>',
		       '    <li><a href="#'+inputTabId+'">input</a></li>',
		       '    <li><a href="#'+bratTabId+'">brat</a></li>',
		       '    <li><a href="#'+infoTabId+'">info</a></li>',
		       '  </ul>',
		       '</div>'
		       ].join('\n'));
	// tab content (divs)
	var inputTab   = $('<div id="'+inputTabId+'"></div>'),
            bratTab = $('<div id="'+bratTabId+'"></div>'),
            logTab  = $('<div id="'+infoTabId+'"></div>');
	inputTab.append(inputArea);
	bratTab.append(bratArea);
	logTab.append(logArea);

	// add content to top-level element, turn into jQuery-ui tabs
	tabDiv.append(inputTab, bratTab, logTab);
	elem.append(shDiv, tabDiv, visDiv);
	tabDiv.tabs();
	var shVisible = 0;
	var setShToggleText = function() {
	    $('span', showHideButton).text(shVisible ? 'hide' : 'edit');
	}
	tabDiv.hide(); // TODO make optional (control e.g. using class)
        showHideButton.button().click(function(ev) {
	   tabDiv.toggle('blind');
	   shVisible = !shVisible;
	   setShToggleText();
	});
	setShToggleText();

        // only show tabs / tab visibility control if set in options
        if (options && !options.tabs) {
            showHideButton.hide();
            tabDiv.hide();
        }

	// initialize brat visualization
        var dispatcher = Util.embed(eId+'-vis',
          $.extend({'collection': null}, collData),
          $.extend({}, parsed), webFontURLs);

	// hook everything up
        var renderError = function() {
            bratArea.css({'border': '2px solid red'});
        };
        dispatcher.on('renderError: Fatal', renderError);

        var inputHandler = function() {
            var parsed, parse_error = false;

	    logArea.val(''); // clear log

            try {
                parsed = parse(inputArea.val(), makeLogger(logArea));
		parse_error = parsed.error;
            } catch (e) {
		console.log(e);
		parse_error = true;
            }

	    // console.log(parse_error);

	    if (!parse_error) {
                inputArea.css({'border': '2px inset'});
	    } else {
                inputArea.css({'border': '2px solid red'});
                return;
	    }
    
	    bratArea.text(ObjectToString(parsed));

            try {
                dispatcher.post('requestRenderData', [$.extend({}, parsed)]);
                bratArea.css({'border': '2px inset'});
            } catch(e) {
		console.log('requestRenderData error:', e);
		logArea.append('requestRenderData error: '+e);
                bratArea.css({'border': '2px solid red'});
            }
        };
        inputArea.bind('propertychange keyup input paste', inputHandler);
    };

    var resolveEmbeddedReference = function(elem, data) {
	var refId = elem.attr('href'),
	    refElem = $(refId);
	
	if (refElem === undefined) {
	    console.log('Failed to resolve reference to', refId, 'for', elem);
	    return;
	}

	var refSeq = refElem.attr('embeddedSequenceNum');
	if (refSeq === undefined) {
	    console.log('no embeddedSequenceNum for', refElem);
	    return;
	}

	var origText = elem.text();
	var resolvedText = origText.replace(/\#/, refSeq);
	if (origText === resolvedText) {
	    console.log('failed replace in text', origText, 'for', elem);
	    return;
	}

	elem.text(resolvedText);
    };

    var embedBratVisualizations = function() {
        // generate embedded visualizations: call embedDependency
	// for elements with "sd-parse" class.
        $('.sd-parse').each(function(idx) {
            embedDependency($(this), sdParse);
	});

        // repeat for elements with "conllx-parse" class.
        $('.conllx-parse').each(function(idx) {
            embedDependency($(this), conllXParse);
	});

	// resolve references (e.g. "Figure #" -> "Figure 1"): call
	// resolveEmbeddedReference for elements with "embed-ref" class.
	$('.embed-ref').each(function(idx) {
            resolveEmbeddedReference($(this));
	});
    };

    head.ready(function() {
	// just call this in head.ready()
	embedBratVisualizations();
    });
</script>


      <div id="footer">
          <p class="footer-text">embedded brat &copy; 2010-2014 the <a href="http://brat.nlplab.org/about.html" style="color:gray">brat contributors</a></p>
      </div>
    </div>
  </body>
</html>
