

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Finnish grammatical relations</title>
    <link rel="stylesheet" type="text/css" href="css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <link rel="stylesheet" type="text/css" href="http://weaver.nlplab.org/~brat/demo/v1.3/style-vis.css"/>
    <script type="text/javascript" src="http://weaver.nlplab.org/~brat/demo/v1.3/client/lib/head.load.min.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->
  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
          <span class="header-text"><a href="http://universaldependencies.github.io/docs/">home</a></span>

          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <p>Note: This document is a draft. Not all relations have been converted to USD-compatible description yet.</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Core dependents of clausal predicates</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a href="fi/nsubj.html">nsubj</a></td>
	  <td><a href="fi/csubj.html">csubj</a></td>
	</tr>
	<tr>
	  <td><a href="fi/nsubj-cop.html">↳nsubj-cop</a></td>
	  <td><a href="fi/csubj-cop.html">↳csubj-cop</a></td>
	</tr>
	<tr>
	  <td><strike>nsubjpass</strike></td>
	  <td><strike>csubjpass</strike></td>
	</tr>
	<tr>
	  <td><a href="fi/dobj.html">dobj</a></td>
	  <td><a href="fi/ccomp.html">ccomp</a></td>
	  <td><a href="fi/xcomp.html">xcomp</a></td>
	</tr>
	<tr>
	  <td />
	  <td><a href="fi/iccomp.html">↳iccomp</a></td>
	  <td />
	</tr>
	<tr>
	  <td><strike>iobj</strike></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Non-core dependents of clausal predicates</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a href="fi/advcl.html">advcl</a></td>
	  <td><a href="fi/advmod.html">advmod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a href="fi/nfincl.html">nfincl</a></td>
	  <td><a href="fi/neg.html">neg</a></td>
	</tr>
	<tr>
	  <td><a href="fi/nmod.html">nmod</a></td>
	  <td><a href="fi/ncmod.html">ncmod</a></td>
	</tr>
	<tr>
	  <td><a href="fi/nmod-own.html">↳nmod-own</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Special clausal dependents</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a href="fi/vocative.html">vocative</a></td>
	  <td><a href="fi/aux.html">aux</a></td>
	  <td><a href="fi/mark.html">mark</a></td>
	</tr>
	<tr>
	  <td><a href="fi/discourse.html">discourse</a></td>
	  <td><a href="fi/auxpass.html">auxpass</a></td>
	  <td><a href="fi/punct.html">punct</a></td>
	</tr>
	<tr>
	  <td><a href="fi/expl.html">expl</a></td>
	  <td><a href="fi/cop.html">cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Noun dependents</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a href="fi/nummod.html">nummod</a></td>
	  <td><a href="fi/relcl.html">relcl</a></td>
	  <td><a href="fi/amod.html">amod</a></td>
	</tr>
	<tr>
	  <td><a href="fi/appos.html">appos</a></td>
	  <td><a href="fi/nfincl.html">nfincl</a></td>
	  <td><a href="fi/det.html">det</a></td>
	</tr>
	<tr>
	  <td><a href="fi/nmod.html">nmod</a></td>
	  <td><a href="fi/ncmod.html">ncmod</a></td>
	  <td><a href="fi/neg.html">neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Compounding and unanalyzed</b></td></tr>
	<tr>
	  <td><a href="fi/compound.html">compound</a></td>
	  <td><a href="fi/mwe.html">mwe</a></td>
	  <td><a href="fi/goeswith.html">goeswith</a></td>
	</tr>
	<tr>
	  <td><a href="fi/name.html">name</a></td>
	  <td><a href="fi/foreign.html">foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Coordination</b></td></tr>
	<tr>
	  <td><a href="fi/conj.html">conj</a></td>
	  <td><a href="fi/cc.html">cc</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Case-marking, prepositions, possessive</b></td></tr>
	<tr>
	  <td><a href="fi/case.html">case</a></td>
	</tr>
	<tr>
	  <td><a href="fi/poss.html">↳poss</a></td>
	</tr>
	<tr>
	  <td><a href="fi/gsubj.html">↳gsubj</a></td>
	</tr>
	<tr>
	  <td><a href="fi/gobj.html">↳gobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Loose joining relations</b></td></tr>
	<tr>
	  <td><a href="fi/list.html">list</a></td>
	  <td><a href="fi/parataxis.html">parataxis</a></td>
	  <td><a href="fi/remnant.html">remnant</a></td>
	</tr>
	<tr>
	  <td><a href="fi/dislocated.html">dislocated</a></td>
	  <td></td><td><a href="fi/reparandum.html">reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Other</b></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a href="fi/root.html">root</a></td>
	  <td><a href="fi/dep.html">dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<p>Note: <i>nmod</i>, <i>ncmod</i>, <i>nfincl</i>, and <i>neg</i> appear
in two places.</p>

<hr />

<h2 id="acomp-adjectival-complement">acomp (adjectival complement)</h2>

<p>The dependency type <code>acomp</code> is used for adjectival complements of verbs, except for predicatives.</p>

<div class="sd-parse">
Hän teki siitä hyvin vaikeaa . \n He made (from_)it very difficult .
nsubj(teki, Hän)
nmod(teki, siitä)
advmod(vaikeaa, hyvin)
acomp(teki, vaikeaa)
punct(teki, .)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/acomp.md" target="#">edit acomp</a></p>

<h2 id="advcl-adverbial-clause-modifier">advcl (adverbial clause modifier)</h2>

<p><em>Adverbial clause modifiers</em> (<code>advcl</code>) are subordinate clauses that are not complements. Also non-complement infinite or temporal clauses (<em>lauseenvastike</em>, see for instance (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=876">§876</a>) are marked as <code>advcl</code>. If there is a subordinating conjunction present, it is marked with the dependency type <code>mark</code> (see Section <a href="http://universaldependencies.github.io/docs/fi/mark.html">mark</a>).</p>

<!-- fname:advcl.pdf -->
<div class="sd-parse">
Kun äiti tuli kotiin , isä keitti kahvia . \n When mother came home , father made coffee .
mark(tuli-3, Kun-1)
nsubj(tuli-3, äiti-2)
nmod(tuli-3, kotiin-4)
punct(tuli-3, ,-5)
nsubj(keitti-7, isä-6)
advcl(keitti-7, tuli-3)
dobj(keitti-7, kahvia-8)
punct(keitti-7, .-9)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/advcl.md" target="#">edit advcl</a></p>

<h2 id="advmod-adverb-modifier-a-namesec-advmoda">advmod (adverb modifier) <a name="sec-advmod"></a></h2>

<p>The dependency type <code>advmod</code> is used for <em>adverb modifiers</em> of verbs, nominals and adverbs alike.</p>

<!-- fname:advmod_verb.pdf -->
<div class="sd-parse">
Hän käveli kotiin hitaasti . \n He walked home slowly .
nsubj(käveli-2, Hän-1)
nmod(käveli-2, kotiin-3)
advmod(käveli-2, hitaasti-4)
punct(käveli-2, .-5)
</div>

<!-- fname:advmod_noun.pdf -->
<div class="sd-parse">
Minä otin kaapista myös vasaran . \n I took from_closet also hammer .
nsubj(otin-2, Minä-1)
nmod(otin-2, kaapista-3)
dobj(otin-2, vasaran-5)
advmod(vasaran-5, myös-4)
punct(otin-2, .-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/advmod.md" target="#">edit advmod</a></p>

<h2 id="amod-adjectival-modifier">amod (adjectival modifier)</h2>

<p>Nouns may take adjectival modifiers, which are marked with the dependency type <code>amod</code>. It is also possible for an adjective to take another adjective as a modifier. (These adjectival modifiers are generally expressed with <em>-ly</em> adverbs in English.)</p>

<!-- fname:amod_noun.pdf -->
<div class="sd-parse">
Tien vieressä on suuri kivi . \n Road next_to is large rock .
nmod(on-3, Tien-1)
adpos(Tien-1, vieressä-2)
nsubj(on-3, kivi-5)
amod(kivi-5, suuri-4)
punct(on-3, .-6)
</div>

<!-- fname:amod_adjective.pdf -->
<div class="sd-parse">
poikkeuksellisen suuri kivi \n exceptional(ly) large rock
amod(suuri-2, poikkeuksellisen-1)
amod(kivi-3, suuri-2)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/amod.md" target="#">edit amod</a></p>

<h2 id="appos-apposition-a-namesec-apposa">appos (apposition) <a name="sec-appos"></a></h2>

<p>An <em>apposition</em> (<code>appos</code>) is a grammaticalized, paradigmatic addition (usually a noun phrase), which has the same referent as its head word, and the same grammatical function (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=1059">§1059</a>). Also structures with a <em>supporting noun</em> (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=567">§567</a>) are considered appositional. Appositional structures and the closely related <em>appellation modifiers</em> are discussed in detail below.</p>

<!-- fname:appos1.pdf -->
<div class="sd-parse">
Professori , Matti Tamminen , luennoi tänään . \n The_professor , Matti Tamminen , lectures today .
appos(Professori-1, Tamminen-4)
punct(Tamminen-4, ,-2)
punct(Tamminen-4, ,-5)
name(Tamminen-4, Matti-3)
nsubj(luennoi-6, Professori-1)
advmod(luennoi-6, tänään-7)
punct(luennoi-6, .-8)
</div>

<!-- fname:appos2.pdf -->
<div class="sd-parse">
Kirjassa Putkinotko on mielenkiintoinen juoni . \n In_the_book Putkinotko is interesting plot .
appos(Kirjassa-1, Putkinotko-2)
nmod(on-3, Kirjassa-1)
nsubj(on-3, juoni-5)
amod(juoni-5, mielenkiintoinen-4)
punct(on-3, .-6)
</div>

<p><a href="fi/appos.html">See details</a></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/appos.md" target="#">edit appos</a></p>

<h2 id="aux-auxiliary-a-namesec-auxa">aux (auxiliary) <a name="sec-aux"></a></h2>

<p>In TDT, only a closed list of verbs can act as auxiliaries, including the main modal verbs (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=1562">§1562</a>) and in addition the verbs <em>olla</em> (<em>to be</em>) and <em>aikoa</em> (<em>to be going to</em>). The full list of auxiliaries in TDT is thus as follows:</p>

<ul>
  <li>täytyä (must)</li>
  <li>pitää (have to)</li>
  <li>tarvita (need)</li>
  <li>joutua (have to)</li>
  <li>voida (be able to, can)</li>
  <li>saattaa (may)</li>
  <li>taitaa (be+probably, may)</li>
  <li>mahtaa (be+probably, may)</li>
  <li>olla (be)</li>
  <li>aikoa (be going to)</li>
</ul>

<!-- fname:aux.pdf -->
<div class="sd-parse">
Hän saattoi lähteä jo . \n He may(impf.) leave already .
nsubj(lähteä-3, Hän-1)
aux(lähteä-3, saattoi-2)
advmod(lähteä-3, jo-4)
punct(lähteä-3, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/aux.md" target="#">edit aux</a></p>

<h2 id="auxpass-passive-auxiliary">auxpass (passive auxiliary)</h2>

<p>The only <em>passive auxiliary</em> (<code>auxpass</code>) in Finnish is <em>olla</em> (<em>to be</em>). An auxiliary is only considered a passive auxiliary if the main verb is in passive, not if only the auxiliary is in passive. In the latter case the auxiliary is marked as a non-passive auxiliary, <code>aux</code>. </p>

<!-- TODO The distinction between the passive voice and the zeroth person is discussed in Section \ref{pass-vs-0th}. -->

<!-- fname:auxpass1.pdf -->
<div class="sd-parse">
Suunnitelmaan on tehty muutoksia . \n Into_the_plan have_been made changes .
nmod(tehty-3, Suunnitelmaan-1)
auxpass(tehty-3, on-2)
dobj(tehty-3, muutoksia-4)
punct(tehty-3, .-5)
</div>

<!-- fname:auxpass2.pdf -->
<div class="sd-parse">
Suunnitelmaan voidaan tehdä muutoksia . \n Into_the_plan can_be made(1st_inf.) changes .
nmod(tehdä-3, Suunnitelmaan-1)
aux(tehdä-3, voidaan-2)
dobj(tehdä-3, muutoksia-4)
punct(tehdä-3, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/auxpass.md" target="#">edit auxpass</a></p>

<h2 id="case-case-marking">case (case marking)</h2>

<p>The dependency type <code>case</code> is used for the adposition in pre- and postpositional phrases. In the Finnish-specific SD scheme, the head of an adpositional phrase is the nominal, not the adposition, so as to analyze adpositional phrases similarly to nominal modifiers without an adposition. (Such nominal modifiers are frequent in Finnish, as cases are often used for the same purpose as adpositions.) To the same end, the type <code>case</code> is used in combination with the type <code>nmod</code>, which is also used for nominal modifiers when no adposition is present (see Section <a href="http://universaldependencies.github.io/docs/fi/nmod.html">nmod</a>).</p>

<!-- fname:adpos.pdf -->
<div class="sd-parse">
Talo sijaitsee mäen takana . \n House is_located hill behind .
nsubj(sijaitsee-2, Talo-1)
nmod(sijaitsee-2, mäen-3)
case(mäen-3, takana-4)
punct(sijaitsee-2, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/case.md" target="#">edit case</a></p>

<h2 id="cc-coordinating-conjunction-a-namesec-cca">cc (coordinating conjunction) <a name="sec-cc"></a></h2>

<p><em>Coordinating conjunctions</em> are marked as dependents of the first coordinated element, and the dependency type used is <code>cc</code>. </p>

<!-- fname:cc1.pdf -->
<div class="sd-parse">
kirjat , kynät ja viivottimet \n books , pencils and rulers
conj(kirjat-1, kynät-3)
punct(kirjat-1, ,-2)
cc(kirjat-1, ja-4)
conj(kirjat-1, viivottimet-5)
</div>

<p><a href="fi/cc.html">See details</a></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/cc.md" target="#">edit cc</a></p>

<h2 id="ccomp-clausal-complement-a-namesec-ccompa">ccomp (clausal complement) <a name="sec-ccomp"></a></h2>

<p><em>Clausal complements</em> that have a subject different from that of the main clause (Note that a clausal complement need not have a subject present at all; the clause could be, for instance, passive.)  are marked with the dependency type <code>ccomp</code>. The governor is most commonly, although not always, the main verb or predicative of the main clause, and the dependent is the main verb or predicative of the dependent clause. The clausal complement can also modify a word other than a verb, most often a noun or pronoun. Most commonly clausal complements are <em>että</em>-clauses. <!--Distinguishing different verbal dependents, including different clausal complements, is discussed more closely in Section [verbal](#sec-verbal).--></p>

<!-- fname:ccomp1.pdf -->
<div class="sd-parse">
Sanoin hänelle , että vesi kiehuu . \n I_said to_him , that water boils .
nmod(Sanoin-1, hänelle-2)
ccomp(Sanoin-1, kiehuu-6)
punct(kiehuu-6, ,-3)
complm(kiehuu-6, että-4)
nsubj(kiehuu-6, vesi-5)
punct(Sanoin-1, .-7)
</div>

<!-- fname:ccomp2.pdf -->
<div class="sd-parse">
Se , että naapurin koira haukkui kovasti , suututti äitiä . \n It , that neighbor's dog barked loudly , made_angry mother .
ccomp(Se-1, haukkui-6)
punct(haukkui-6, ,-2)
punct(haukkui-6, ,-8)
poss(koira-5, naapurin-4)
nsubj(haukkui-6, koira-5)
advmod(haukkui-6, kovasti-7)
nsubj(suututti-9, Se-1)
dobj(suututti-9, äitiä-10)
punct(suututti-9, .-11)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/ccomp.md" target="#">edit ccomp</a></p>

<h2 id="compar-comparative">compar (comparative)</h2>

<p>The dependency type <code>compar</code> is used in comparative constructions, most often involving adjectives in the comparative form. The head of the <code>compar</code> dependency is the comparative wordform, and the dependent is the compared element. </p>

<!-- fname:compar.pdf -->
<div class="sd-parse">
parempi kuin eilinen näytelmä \n better than yesterday's(adj.) play
compar(parempi-1, näytelmä-4)
comparator(näytelmä-4, kuin-2)
amod(näytelmä-4, eilinen-3)
</div>

<p><a href="fi/compar.html">See details</a></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/compar.md" target="#">edit compar</a></p>

<h2 id="comparator-comparative-conjunction-a-namesec-comparatora">comparator (comparative conjunction) <a name="sec-comparator"></a></h2>

<p>The <em>comparative conjunction</em> (most commonly <em>kuin</em>, which corresponds roughly to <em>than</em> and <em>as</em> in English) is marked with the dependency type <code>comparator</code>. The head of the dependency is the element being compared.</p>

<!-- fname:comparator.pdf -->
<div class="sd-parse">
enemmän kuin haluaisin \n more than I_would_want
comparator(enemmän-1, haluaisin-3)
comparator(haluaisin-3, kuin-2)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/comparator.md" target="#">edit comparator</a></p>

<h2 id="complm-complementizer-a-namesec-complma">complm (complementizer) <a name="sec-complm"></a></h2>

<p>The <em>complementizer</em> (<em>complm</em>) appears in most clausal complements, and the head of the dependency is the main verb of the subordinate clause. The only complementizer in Finnish is <em>että</em> (<em>that</em>).</p>

<!-- fname:complm.pdf -->
<div class="sd-parse">
Sanoin , että hän voi tulla . \n I_said , that he can come .
ccomp(Sanoin-1, tulla-6)
punct(tulla-6, ,-2)
complm(tulla-6, että-3)
nsubj(tulla-6, hän-4)
aux(tulla-6, voi-5)
punct(Sanoin-1, .-7)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/complm.md" target="#">edit complm</a></p>

<h2 id="compound">compound</h2>

<p>The description of the USD relation <code>compound</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/compound.md" target="#">edit compound</a></p>

<h2 id="conj-coordinated-element">conj (coordinated element)</h2>

<p>The SD scheme marks coordination so that the first coordinated element acts as the head, and the rest of the elements in the coordination, as well as the coordinating conjunction, depend on it. <em>Coordinated elements</em> are marked with the dependency type <code>conj</code>.</p>

<!-- fname:conj.pdf -->
<div class="sd-parse">
maitoa , leipää ja voita \n milk , bread and butter
punct(maitoa-1, ,-2)
conj(maitoa-1, leipää-3)
cc(maitoa-1, ja-4)
conj(maitoa-1, voita-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/conj.md" target="#">edit conj</a></p>

<h2 id="cop-copula">cop (copula)</h2>

<p>Copular clauses receive a special treatment in the SD scheme. The predicative acts as the head word of the clause, and the copular verb depends on it using a <code>cop</code> (<em>copula</em>) dependency. The only copular verb in Finnish is <em>olla</em> (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=891">§891</a>). </p>

<!-- TODO Distinguishing copular structures from other constructs as well as recognizing the subject and the predicative is discussed in Section [copulas](#sec-copulas). -->

<!-- fname:cop.pdf -->
<div class="sd-parse">
Huivi oli punainen . \n The_scarf was red .
nsubj-cop(punainen-3, Huivi-1)
cop(punainen-3, oli-2)
punct(punainen-3, .-4)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/cop.md" target="#">edit cop</a></p>

<h2 id="csubj-cop-clausal-copular-subject">csubj-cop (clausal copular subject)</h2>

<p>A <em>clausal copular subject</em> (<code>csubj-cop</code>) is a clause that acts as the subject of another, copular clause. As in all copular clauses, the predicative acts as the head of the clause and hence it is also the governor of the copular subject. 
<!--The distinction between clauses acting as the copular subject of another clause and so called necessive structures is discussed in Section [necessives](#sec-necessives).--></p>

<!-- fname:csubj-cop.pdf -->
<div class="sd-parse">
Oli hauskaa käydä teatterissa . \n Was fun to_go to_theatre .
cop(hauskaa-2, Oli-1)
csubj-cop(hauskaa-2, käydä-3)
nmod(käydä-3, teatterissa-4)
punct(hauskaa-2, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/csubj-cop.md" target="#">edit csubj-cop</a></p>

<h2 id="csubj-clausal-subject">csubj (clausal subject)</h2>

<p>A <em>clausal subject</em> (<em>csubj</em>) is a clause that acts as the subject of another clause.</p>

<!-- fname:csubj.pdf -->
<div class="sd-parse">
Hänen aikomuksenaan oli mennä ulos . \n His intention(essive) was to_go out .
poss(aikomuksenaan-2, Hänen-1)
nmod(oli-3, aikomuksenaan-2)
csubj(oli-3, mennä-4)
advmod(mennä-4, ulos-5)
punct(oli-3, .-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/csubj.md" target="#">edit csubj</a></p>

<h2 id="dep-dependent-a-namesec-depa">dep (dependent) <a name="sec-dep"></a></h2>

<p>The name of the dependency type <code>dep</code> stands for <em>dependent</em>. It is the most general dependency type in SD, and it is meant to be used when no other, more specific dependency type applies. In TDT, the type <code>dep</code> is mostly used in idiomatic two-word expressions. There are also some fixed three-word expressions in the treebank.</p>

<!-- fname:dep.pdf -->
<div class="sd-parse">
Itse asiassa hän tuli jo eilen . \n As_a matter_of_fact he came already yesterday .
dep(asiassa-2, Itse-1)
advmod(tuli-4, asiassa-2)
nsubj(tuli-4, hän-3)
advmod(tuli-4, eilen-6)
advmod(eilen-6, jo-5)
punct(tuli-4, .-7)
</div>

<p><a href="fi/dep.html">See details</a></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/dep.md" target="#">edit dep</a></p>

<h2 id="det-determiner">det (determiner)</h2>

<p>There are no definite or indefinite articles in the Finnish language, but there are other determiners (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=1409">§1409</a>). In TDT, mostly pronouns are marked as <em>determiners</em> (<code>det</code>), because numerals, which can also be analyzed as determiner-like, are marked as <em>numeral modifiers</em> <a href="http://universaldependencies.github.io/docs/fi/num.html">num</a>, and genitive modifiers, also determiner-like, are marked with <a href="http://universaldependencies.github.io/docs/fi/poss.html">poss</a>.</p>

<!-- fname:det.pdf -->
<div class="sd-parse">
Kaikki miehet pudistivat päätään . \n All men shook their_head .
det(miehet-2, Kaikki-1)
nsubj(pudistivat-3, miehet-2)
dobj(pudistivat-3, päätään-4)
punct(pudistivat-3, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/det.md" target="#">edit det</a></p>

<h2 id="discourse-discourse-element">discourse (discourse element)</h2>

<p><em>Discourse elements</em> are typically exclamations or wordlike entities. They are attached to the main verb or predicative of the sentence with the <code>discourse</code> dependency type.</p>

<!-- fname:intj1.pdf -->
<div class="sd-parse">
Hei , tule auttamaan ! \n Hey , come to_help !
discourse(tule-3, Hei-1)
punct(Hei-1, ,-2)
xcomp(tule-3, auttamaan-4)
punct(tule-3, !-5)
</div>

<!-- fname:intj2.pdf -->
<div class="sd-parse">
Hmm ... Mitähän tuohon sanoisi ? \n Umm ... What to_that to_say ?
discourse(sanoisi-5, Hmm-1)
punct(Hmm-1, ...-2)
dobj(sanoisi-5, Mitähän-3)
nmod(sanoisi-5, tuohon-4)
punct(sanoisi-5, ?-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/discourse.md" target="#">edit discourse</a></p>

<h2 id="dislocated">dislocated</h2>

<p>The description of the USD relation <code>dislocated</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/dislocated.md" target="#">edit dislocated</a></p>

<h2 id="dobj-direct-object">dobj (direct object)</h2>

<p>The dependency type <code>dobj</code> is used for (nominal) direct objects of the verb.</p>

<!-- fname:dobj1.pdf -->
<div class="sd-parse">
Hän sulki oven . \n He closed the_door .
nsubj(sulki-2, Hän-1)
dobj(sulki-2, oven-3)
punct(sulki-2, .-4)
</div>

<p>As in Finnish a passive clause does not have a subject, and what in English would be considered the passive subject, is in Finnish the direct object, the type <code>nsubjpass</code> is not used in TDT, but the type <code>dobj</code> is used instead.</p>

<!-- fname:dobj2.pdf -->
<div class="sd-parse">
Päätös tehtiin marraskuussa . \n The_decision was_made in_November .
dobj(tehtiin-2, Päätös-1)
nmod(tehtiin-2, marraskuussa-3)
punct(tehtiin-2, .-4)
</div>

<!-- Fine distinctions in special cases of subjects, objects and object-cased amount adverbials are discussed in Section [subj-obj](#sec-subj-obj).-->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/dobj.md" target="#">edit dobj</a></p>

<h2 id="expl">expl</h2>

<p>The description of the USD relation <code>expl</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/expl.md" target="#">edit expl</a></p>

<h2 id="foreign">foreign</h2>

<p>The description of the USD relation <code>foreign</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/foreign.md" target="#">edit foreign</a></p>

<h2 id="gobj-genitive-object-a-namesec-gobja">gobj (genitive object) <a name="sec-gobj"></a></h2>

<p>Certain nouns, those which have been directly derived from a verb or otherwise have a verb counterpart, can take an object in Finnish. These objects closely resemble more general genitive modifiers <a href="http://universaldependencies.github.io/docs/fi/poss.html">poss</a>.</p>

<!-- fname:gobj.pdf -->
<div class="sd-parse">
Perunan viljely oli tuolloin harvinaista . \n Potato growing(N) was then rare .
gobj(viljely-2, Perunan-1)
nsubj-cop(harvinaista-5, viljely-2)
cop(harvinaista-5, oli-3)
advmod(harvinaista-5, tuolloin-4)
punct(harvinaista-5, .-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/gobj.md" target="#">edit gobj</a></p>

<h2 id="goeswith">goeswith</h2>

<p>The description of the USD relation <code>goeswith</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/goeswith.md" target="#">edit goeswith</a></p>

<h2 id="genitive-subject-a-namesec-gsubja">genitive subject <a name="sec-gsubj"></a></h2>

<p><em>Genitive subjects</em> are subject-like arguments taken by a noun. This is in parallel to genitive objects <a href="http://universaldependencies.github.io/docs/fi/gobj.html">gobj</a>.
<!-- %% \footnote{Due to genitive subjects being For further discussion on subjects and objects of nouns, see Section [gsubj-gobj](#sec-gsubj-gobj). --></p>

<!-- fname:gsubj.pdf -->
<div class="sd-parse">
maljakon särkyminen \n vase(gen.) breaking
gsubj(särkyminen-2, maljakon-1)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/gsubj.md" target="#">edit gsubj</a></p>

<h2 id="iccomp-infinite-clausal-complement-a-namesec-iccompa">iccomp (infinite clausal complement) <a name="sec-iccomp"></a></h2>

<p>The dependency type <code>iccomp</code>, which stands for <em>infinite clausal complement</em>, is a subtype of <code>ccomp</code> (<em>clausal complement</em>). It is used for clausal complements where the complement clause has a different subject from that of the governing clause and is infinite, i.e. where the verb is an infinitive or a participle. </p>

<!-- TODO The differences between types of verbal dependents, such as `iccomp`, are thoroughly discussed in Section [verbal](#sec-verbal). -->

<!-- fname:iccomp.pdf -->
<div class="sd-parse">
Sain hänet itkemään . \n I_made him cry .
iccomp(Sain-1, itkemään-3)
nsubj(itkemään-3, hänet-2)
punct(Sain-1, .-4)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/iccomp.md" target="#">edit iccomp</a></p>

<h2 id="infmod-infinitive-modifier">infmod (infinitive modifier)</h2>

<p>The dependency type <code>infmod</code> is used for infinitives that modify a nominal or a noun phrase.</p>

<!-- fname:infmod.pdf -->
<div class="sd-parse">
Minulla oli lupa mennä ulos . \n I had permission to_go out .
nmod(oli-2, Minulla-1)
nsubj(oli-2, lupa-3)
infmod(lupa-3, mennä-4)
advmod(mennä-4, ulos-5)
punct(oli-2, .-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/infmod.md" target="#">edit infmod</a></p>

<h2 id="list">list</h2>

<p>The description of the USD relation <code>list</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/list.md" target="#">edit list</a></p>

<h2 id="mark-marker-a-namesec-marka">mark (marker) <a name="sec-mark"></a></h2>

<p>A <em>marker</em> (<code>mark</code>) is the subordinating conjunction in a non-complement subordinate clause.</p>

<!-- fname:mark.pdf -->
<div class="sd-parse">
Kun tulin kotiin , jätin avaimen pöydälle . \n When I_came home , I_left key on_table .
mark(tulin-2, Kun-1)
nmod(tulin-2, kotiin-3)
punct(tulin-2, ,-4)
advcl(jätin-5, tulin-2)
dobj(jätin-5, avaimen-6)
nmod(jätin-5, pöydälle-7)
punct(jätin-5, .-8)
</div>

<p>The main subordinating conjunctions in TDT are:</p>

<ul>
  <li>että (that)</li>
  <li>jotta (so that)</li>
  <li>koska (because)</li>
  <li>kun (when)</li>
  <li>jos (if)</li>
  <li>vaikka (even though)</li>
  <li>kunnes (until)</li>
  <li>kuin (as, than)</li>
</ul>

<p>Note that the conjunction <em>että</em> (usually) starts a complement clause, in which case it is marked as a complementizer <a href="http://universaldependencies.github.io/docs/fi/complm.html">complm</a>. On a similar note, the conjunction <em>kuin</em> also has several uses. In addition to a subordinating conjunction, it can also serve as an adverb modifier <a href="http://universaldependencies.github.io/docs/fi/advmod.html">advmod</a> as well as a comparative conjunction <a href="http://universaldependencies.github.io/docs/fi/comparator.html">comparator</a>.</p>

<p>In addition to the basic subordinating conjunctions, the following words or word combinations can be considered subordinating conjunctions in TDT. Not all of these expressions have a direct counterpart in English, and thus the translations are approximate.</p>

<ul>
  <li>ennenkuin (before)</li>
  <li>jahka (as soon as)</li>
  <li>jos kohta (even if)</li>
  <li>kun taas (whereas)</li>
  <li>kuten (like, as)</li>
  <li>mikäli (if)</li>
  <li>mitä nyt (only)</li>
  <li>muuten (otherwise)</li>
  <li>niin (so)</li>
  <li>niinkuin/niinku (like, standard and colloquial version)</li>
  <li>paitsi (except)</li>
  <li>paitsi että (except that)</li>
  <li>paitsi jos (except if)</li>
  <li>sikäli kuin (if)</li>
  <li>sillä (because)</li>
  <li>sitten kun (then when)</li>
  <li>vähän kuin (a bit like)</li>
</ul>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/mark.md" target="#">edit mark</a></p>

<h2 id="mwe">mwe</h2>

<p>The description of the USD relation <code>mwe</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/mwe.md" target="#">edit mwe</a></p>

<h2 id="name-multi-word-named-entity-a-namesec-namea">name (multi-word named entity) <a name="sec-name"></a></h2>

<p>Multi-word named entities are marked using the dependency type <code>name</code>. The rightmost word of the named entity is considered the head, and the leftmost word is the dependent. If there are more than two words, these are not marked in any way, as the <code>name</code> dependency can be expanded automatically if needed.</p>

<p>There are two different cases in which the dependency type appears. If the multi-word named entity does not have an obvious internal syntactic structure, as is the case with for instance names of people (<em>Matti Virtanen</em>) or cities (<em>New York City</em>), only the <code>name</code> dependency is used.</p>

<p>If the named entity has an obvious internal structure, as is often the case in names of books and movies for instance, this structure is marked as well, and the <code>name</code> dependency is placed on top of this structure, despite it being extraneous in the tree. In these cases, the head of the internal structure, not the rightmost word of the named entity, is considered to be the true syntactic head. It is possible for the user of the treebank to choose their preferred analysis for these cases according to need, and automatically discard the alternative analysis.</p>

<!-- fname:name.pdf -->
<div class="sd-parse">
Jumalat juhlivat öisin on Donna Tarttin esikoisteos . \n Gods celebrate by_night is Donna Tartt's first_work .
nsubj(juhlivat-2, Jumalat-1)
nmod(juhlivat-2, öisin-3)
name(öisin-3, Jumalat-1)
nsubj-cop(esikoisteos-7, juhlivat-2)
cop(esikoisteos-7, on-4)
punct(esikoisteos-7, .-8)
name(Tarttin-6, Donna-5)
poss(esikoisteos-7, Tarttin-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/name.md" target="#">edit name</a></p>

<h2 id="ncmod">ncmod</h2>

<p>The description of the USD relation <code>ncmod</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/ncmod.md" target="#">edit ncmod</a></p>

<h2 id="neg-negation-marker">neg (negation marker)</h2>

<p>In Finnish, negation is marked using the verb <em>ei</em>, which is used as an auxiliary. This means that the <em>negation marker</em> (<code>neg</code>) is a subtype of <a href="http://universaldependencies.github.io/docs/fi/aux.html">aux</a>. The most commonly negated elements are verbs and verb phrases, but occasional exceptions in verbless constructions are allowed.</p>

<p>If a conjunction or adverb has been merged together with <em>ei</em>, as in for instance <em>ettei</em> (<em>että+ei</em>, <em>that+not</em>) or <em>miksei</em> (<em>miksi+ei</em>, <em>why+not</em>), then the word is marked as a conjunction or an adverb rather than a negation verb. However, <em>eikä (and+not)</em>, when it appears alone and not coordinating another clause or phrase, is still marked as <code>neg</code>.</p>

<!-- fname:neg.pdf -->
<div class="sd-parse">
Hän ei sanonut mitään . \n He didn't say anything .
nsubj(sanonut-3, Hän-1)
neg(sanonut-3, ei-2)
dobj(sanonut-3, mitään-4)
punct(sanonut-3, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/neg.md" target="#">edit neg</a></p>

<h2 id="nfincl">nfincl</h2>

<p>The description of the USD relation <code>nfincl</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nfincl.md" target="#">edit nfincl</a></p>

<h2 id="nmod-own-haver-a-namesec-omistusa">nmod-own (haver) <a name="sec-omistus"></a></h2>

<p>In Finnish, there is no equivalent for the verb <em>have</em>. Rather, <em>having</em> is expressed using the verb <em>olla</em>, <em>to be</em>. For instance, the meaning of the sentence <em>I have a pen</em> would be expressed in Finnish by <em>Minulla on kynä</em>, literally <em>“At me is a pen”</em>. In TDT, these so called <em>possessive clauses</em> (omistuslause)  are analyzed as a subtype to <em>existential clauses</em>, (eksistentiaalilause)  making the thing had (<em>kynä</em> in the previous example) the subject. </p>

<!-- TODO For more information on special cases of subjects, see Section [subj-obj](#sec-subj-obj). -->

<p>This kind of an analysis would naturally result in the <em>haver</em> being marked as a nominal modifier, <em>nmod</em>. However, as <code>nmod</code> is a very frequent dependency type that encodes many different meanings, the information that the clause is about having or owning would be lost. Therefore, the Finnish-specific SD scheme introduces a separate dependency type for nominal modifiers that encode owning, <code>nmod-own</code>. The governor of the dependency is the verb <em>olla</em>, and the dependent is the haver or owner, which is required to be in the <em>adessive</em> case. The haver must also be an animate being or a group of animate beings.</p>

<!-- fname:omistus.pdf -->
<div class="sd-parse">
Matilla on uusi auto . \n At_Matti is new car .
nmod-own(on-2, Matilla-1)
nsubj(on-2, auto-4)
amod(auto-4, uusi-3)
punct(on-2, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nmod-own.md" target="#">edit nmod-own</a></p>

<h2 id="nmod-nominal-modifier-a-namesec-nmoda">nmod (nominal modifier) <a name="sec-nmod"></a></h2>

<p><em>Nominal modifiers</em> are inflected nominals which modify most commonly a verb or a noun phrase. They can occur alone or together with an adposition in an adpositional phrase. Both cases are analyzed similarly, as semantically nominal modifiers and adpositional phrases are similar.</p>

<!-- fname:nmod_alone.pdf -->
<div class="sd-parse">
Maljakko oli pöydällä . \n The_vase was on_the_table .
nsubj(oli-2, Maljakko-1)
nmod(oli-2, pöydällä-3)
punct(oli-2, .-4)
</div>

<!-- fname:nmod_adpos.pdf -->
<div class="sd-parse">
Maljakko oli pöydän päällä . \n The_vase was table on_top_of .
nsubj(oli-2, Maljakko-1)
nmod(oli-2, pöydän-3)
adpos(pöydän-3, päällä-4)
punct(oli-2, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nmod.md" target="#">edit nmod</a></p>

<h2 id="nn-noun-compound-modifier-a-namesec-nna">nn (noun compound modifier) <a name="sec-nn"></a></h2>

<p>The dependency type <code>nn</code>, which stands for <em>noun compound modifier</em> has two basic uses in the Finnish SD scheme. The first use involves actual compounds. In Finnish, compounds are generally written as a single word, but for instance some compounds involving foreign words or proper names are written separately using a dash, and in written Finnish, erroneously writing compounds as two words is a common mistake. Both of these cases are marked using <code>nn</code>.</p>

<!-- fname:nn_foreign.pdf -->
<div class="sd-parse">
Da Vinci -merkkinen luomiväri \n Da Vinci -make eyeshadow
name(Vinci-2, Da-1)
nn(-merkkinen-3, Vinci-2)
amod(luomiväri-4, -merkkinen-3)
</div>

<!-- fname:nn_error.pdf -->
<div class="sd-parse">
Ruoka pöytä notkui herkkuja . \n Food table was_full_of goodies .
nn(pöytä-2, Ruoka-1)
nsubj(notkui-3, pöytä-2)
dobj(notkui-3, herkkuja-4)
punct(notkui-3, .-5)
</div>

<p>The second use of the type <code>nn</code> is to mark <em>appellation modifiers</em>, which are modifying, non-inflecting noun phrases that generally express profession, rank, position, assignment or other such classifiable property (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=1062">§1062</a>). The phenomenon is closely related to that of <em>apposition</em>.</p>

<!-- , and the distinction between the two is described in Section [appos-vs-nn](#sec-appos-vs-nn).-->

<!-- fname:nn_appellation.pdf -->
<div class="sd-parse">
Professori Matti Tamminen pitää puheen . \n Professor Matti Tamminen gives a_speech .
nn(Tamminen-3, Professori-1)
name(Tamminen-3, Matti-2)
nsubj(pitää-4, Tamminen-3)
dobj(pitää-4, puheen-5)
punct(pitää-4, .-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nn.md" target="#">edit nn</a></p>

<h2 id="nsubj-cop-nominal-copular-subject">nsubj-cop (nominal copular subject)</h2>

<p>The dependency type <code>nsubj-cop</code> is used for the nominal subject of a copular clause. The predicative is the head of the copular clause, and also the governor of the <code>nsubj-cop</code> dependency. </p>

<!-- Annotating copular clauses is discussed in Section [copulas](#sec-copulas).-->

<!-- fname:nsubj-cop.pdf -->
<div class="sd-parse">
Matto on jo kuiva . \n The_mat is already dry .
nsubj-cop(kuiva-4, Matto-1)
cop(kuiva-4, on-2)
advmod(kuiva-4, jo-3)
punct(kuiva-4, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nsubj-cop.md" target="#">edit nsubj-cop</a></p>

<h2 id="nsubj-nominal-subject">nsubj (nominal subject)</h2>

<p>The dependency type <code>nsubj</code> marks nominal subjects of the non-copular clause. 
<!-- For thorough discussion of different types of subjects in Finnish, see Section [subj-obj](#sec-subj-obj).--></p>

<!-- fname:nsubj_basic.pdf -->
<div class="sd-parse">
Eeva tuli töistä . \n Eeva came from_work .
nsubj(tuli-2, Eeva-1)
nmod(tuli-2, töistä-3)
punct(tuli-2, .-4)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nsubj.md" target="#">edit nsubj</a></p>

<h2 id="number-numerical-expression">number (numerical expression)</h2>

<p>Numerical expressions consisting of multiple tokens are annotated using the <code>number</code> dependency type. The last word of the numerical expression is the governor, and the number dependencies are chained. </p>

<!-- TODO Special cases of numerical expressions are discussed in Section [numberspecial](#sec-numberspecial). -->

<!-- fname:number.pdf -->
<div class="sd-parse">
Poikasia on yleensä 3 - 5 . \n Youngsters are usually 3 to 5 .
nsubj-cop(5-6, Poikasia-1)
cop(5-6, on-2)
advmod(5-6, yleensä-3)
number(--5, 3-4)
number(5-6, --5)
punct(5-6, .-7)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/number.md" target="#">edit number</a></p>

<h2 id="nummod-numeral-modifier-a-namesec-nummoda">nummod (numeral modifier) <a name="sec-nummod"></a></h2>

<p><em>Numeral modifiers</em> of a noun or NP, including both cardinal and ordinal numbers, are marked with the <code>nummod</code> dependency type. This dependency type is used also with for instance years and program versions.</p>

<!-- fname:num.pdf -->
<div class="sd-parse">
Laukku painoi 20 kiloa . \n Bag weighed 20 kilograms .
nsubj(painoi-2, Laukku-1)
dobj(painoi-2, kiloa-4)
nummod(kiloa-4, 20-3)
punct(painoi-2, .-5)
</div>

<!-- fname:num_year.pdf -->
<div class="sd-parse">
Tapasin hänet vuonna 1972 . \n I_met him in_the_year 1972 .
dobj(Tapasin-1, hänet-2)
nmod(Tapasin-1, vuonna-3)
nummod(vuonna-3, 1972-4)
punct(Tapasin-1, .-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/nummod.md" target="#">edit nummod</a></p>

<h2 id="parataxis-parataxis">parataxis (parataxis)</h2>

<p><code>Parataxis</code> dependencies mark two different phenomena. Firstly, they are used with certain implicit coordinations. These coordinations are recognized by two factors: there is no coordinating conjunction, and the independent clauses are separated by a colon, semicolon or a dash. As with explicit coordinations, the first element is the governor. Also parenthetical clauses can receive the <code>parataxis</code> dependency. If there is a coordinating conjunction present (regardless of punctuation) or if the clauses are separated by merely a comma, the coordination type <code>conj</code> is used.</p>

<!-- fname:parataxis_coord.pdf -->
<div class="sd-parse">
Lapset leipoivat piparit ; äiti paistoi ne . \n The_children made the_cookies ; the_mother baked them .
nsubj(leipoivat-2, Lapset-1)
dobj(leipoivat-2, piparit-3)
punct(leipoivat-2, ;-4)
punct(leipoivat-2, .-8)
parataxis(leipoivat-2, paistoi-6)
nsubj(paistoi-6, äiti-5)
dobj(paistoi-6, ne-7)
</div>

<p><code>Parataxis</code> is also used for direct speech. The verb of saying (or thinking, etc.)  acts as the governor, and the main verb or predicative of the utterance is the dependent.</p>

<!-- fname:parataxis_speech.pdf -->
<div class="sd-parse">
Tulen kotiin vasta myöhään , mies sanoi . \n I_will_come home only late , the_man said .
nmod(Tulen-1, kotiin-2)
advmod(Tulen-1, myöhään-4)
advmod(myöhään-4, vasta-3)
punct(Tulen-1, ,-5)
nsubj(sanoi-7, mies-6)
parataxis(sanoi-7, Tulen-1)
punct(sanoi-7, .-8)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/parataxis.md" target="#">edit parataxis</a></p>

<h2 id="partmod-participal-modifier">partmod (participal modifier)</h2>

<p>The <em>participal modifier</em> (<code>partmod</code>) most commonly modifies a noun phrase. Note that the participle (Also the MA-derivation is treated as a participle in TDT.)  can take arguments, for instance a subject, just as any verb.</p>

<!-- fname:partmod_NP.pdf -->
<div class="sd-parse">
Äidin leipoma kakku oli menestys . \n Mother baked_by cake was success .
nsubj(leipoma-2, Äidin-1)
partmod(kakku-3, leipoma-2)
nsubj-cop(menestys-5, kakku-3)
cop(menestys-5, oli-4)
punct(menestys-5, .-6)
</div>

<!-- fname:partmod_NP_2.pdf -->
<div class="sd-parse">
Saadut lahjat ilahduttivat lapsia . \n Received presents made_happy children .
partmod(lahjat-2, Saadut-1)
nsubj(ilahduttivat-3, lahjat-2)
dobj(ilahduttivat-3, lapsia-4)
punct(ilahduttivat-3, .-5)
</div>

<p>Occasionally, participles can modify a verb as well. These uses include cases that are clearly modifiers, as well as some more complement-like situations. Note that in the complement-like cases of <code>partmod</code>, the complement is not a clause; otherwise it would be marked as an <em>infinite clausal complement</em> <a href="http://universaldependencies.github.io/docs/fi/iccomp.html">iccomp</a>.</p>

<!-- fname:partmod_VP_mod.pdf -->
<div class="sd-parse">
Huolestuneena juoksin hänen luokseen . \n Worried I_ran him to .
partmod(juoksin-2, Huolestuneena-1)
nmod(juoksin-2, hänen-3)
adpos(hänen-3, luokseen-4)
punct(juoksin-2, .-5)
</div>

<!-- fname:partmod_VP_comp.pdf -->
<div class="sd-parse">
Ksylitoli osoittautui kariesta ehkäiseväksi . \n Xylitol turned_out karies preventing .
nsubj(osoittautui-2, Ksylitoli-1)
partmod(osoittautui-2, ehkäiseväksi-4)
dobj(ehkäiseväksi-4, kariesta-3)
punct(osoittautui-2, .-5)
</div>

<!-- TODO For more information on different verb-headed constructions as dependents, see Section [verbal](#sec-verbal). -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/partmod.md" target="#">edit partmod</a></p>

<h2 id="poss-genitive-modifier-a-namesec-possa">poss (genitive modifier) <a name="sec-poss"></a></h2>

<p>The dependency type <code>poss</code> stands for <em>possessive</em> in the original SD scheme, but in TDT, it is used for genitive modifiers in general, which in Finnish often but not nearly always imply possession. There are two kinds of genitive modifiers that are not annotated using the general genitive modifier type: <em>the genitive object</em>, <a href="http://universaldependencies.github.io/docs/fi/gobj.html">gobj</a> and <em>the genitive subject</em>, <a href="http://universaldependencies.github.io/docs/fi/gsubj.html">gsubj</a>.</p>

<!-- fname:poss1.pdf -->
<div class="sd-parse">
Matin penaali jäi kouluun . \n Matti's pencilcase was_left at_school .
poss(penaali-2, Matin-1)
nsubj(jäi-3, penaali-2)
nmod(jäi-3, kouluun-4)
punct(jäi-3, .-5)
</div>

<!-- fname:poss2.pdf -->
<div class="sd-parse">
Autossa on kahden litran moottori . \n In_the_car is two litre's engine .
nmod(on-2, Autossa-1)
nsubj(on-2, moottori-5)
punct(on-2, .-6)
poss(moottori-5, litran-4)
num(litran-4, kahden-3)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/poss.md" target="#">edit poss</a></p>

<h2 id="preconj-preconjunction-a-namesec-preconja">preconj (preconjunction) <a name="sec-preconj"></a></h2>

<p><em>Preconjunction</em> (<code>preconj</code>) marks the first part of those two-part coordinating conjunctions where the two parts are separated by coordinated elements.</p>

<!-- fname:preconj.pdf -->
<div class="sd-parse">
sekä talo että piha \n both house and yard
preconj(talo-2, sekä-1)
cc(talo-2, että-3)
conj(talo-2, piha-4)
</div>

<p>Such two-part coordinating conjunctions in TDT are:</p>

<ul>
  <li>joko… tai (either… or)</li>
  <li>milloin… milloin (when… when)</li>
  <li>mitä… sitä (the… the)</li>
  <li>niin… kuin (as well as)</li>
  <li>paitsi… myös (not only… but also)</li>
  <li>sekä… että (both… and)</li>
  <li>sitä… mitä (the… the)</li>
  <li>sitä mukaa… mitä (a version of <em>the… the</em>)</li>
  <li>toisaalta… ja toisaalta (on the one hand… and on the other hand)</li>
  <li>toisaalta… mutta toisaalta (on the one hand… but on the other hand)</li>
  <li>toisaalta… toisaalta (on the one hand… on the other hand)</li>
  <li>vuoroin… vuoroin (in turn… in turn)</li>
  <li>yhtä lailla… kuin (+kin) (as much… as also)</li>
</ul>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/preconj.md" target="#">edit preconj</a></p>

<h2 id="prt-phrasal-particle">prt (phrasal particle)</h2>

<p><em>Phrasal particles</em> (<code>prt</code>) are used in connection with <em>phrasal verbs</em>, (partikkeliverbi, “particle verb” in Finnish grammar)  where the particle is considered an integral part of the verb expression. The governor of the dependency is the verb, and the dependent is the phrasal particle.</p>

<!-- fname:prt.pdf -->
<div class="sd-parse">
Kävi ilmi , että ehdotus oli hyvä . \n Turned out , that the_suggestion was good .
prt(Kävi-1, ilmi-2)
csubj(Kävi-1, hyvä-7)
punct(hyvä-7, ,-3)
complm(hyvä-7, että-4)
nsubj-cop(hyvä-7, ehdotus-5)
cop(hyvä-7, oli-6)
punct(hyvä-7, .-8)
</div>

<p>Verb particles (see ISK <a href="http://scripta.kotus.fi/visk/sisallys.php?p=455">§455</a> and <a href="http://scripta.kotus.fi/visk/sisallys.php?p=658">§658</a>) are the only case where particles are distinguished from adverbs in TDT. This distinction can be made by the following rough rules. A word is a verbal particle if it, together with the verb, forms an expression that has a meaning that differs from the meaning of the verb alone, and if the word cannot be modified by an adverb.</p>

<p>For instance, <em>laittaa kiinni</em> (<em>make closed, close</em>) is not a phrasal verb, as <em>kiinni</em> can be modified.</p>

<p><em>Laitoin oven kokonaan kiinni. (I closed the door entirely.)</em></p>

<p>In contrast, <em>ottaa kiinni</em> (<em>catch</em>) is a phrasal verb, as it has a meaning distinct from the verb <em>ottaa</em> (<em>take</em>), and <em>kiinni</em> cannot be modified.</p>

<p><em>*Poliisi otti rosvon kokonaan kiinni. (*The police caught the robber entirely.)</em></p>

<p><a href="fi/prt.html">See details</a></p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/prt.md" target="#">edit prt</a></p>

<h2 id="punct-punctuation">punct (punctuation)</h2>

<p>The dependency type <code>punct</code> is used to mark punctuation. The dependent is the punctuation symbol, and the governor is the element which the punctuation symbol delimits. For instance, with coordination, the first coordinated element is the head of all <code>punct</code> dependencies in the coordination, and with subordinate clauses, the head of the subordinate clause is the governor of the <code>punct</code>.</p>

<!-- fname:punct_coord.pdf -->
<div class="sd-parse">
kerrostaloja , rivitaloja ja omakotitaloja \n blockhouses , rowhouses and one_family_houses
punct(kerrostaloja-1, ,-2)
conj(kerrostaloja-1, rivitaloja-3)
cc(kerrostaloja-1, ja-4)
conj(kerrostaloja-1, omakotitaloja-5)
</div>

<!-- fname:punct_subord.pdf -->
<div class="sd-parse">
Kotona oli hiljaista , kun hän palasi . \n At_home was quiet , when he returned .
advmod(oli-2, Kotona-1)
acomp(oli-2, hiljaista-3)
advcl(oli-2, palasi-7)
punct(palasi-7, ,-4)
punct(oli-2, .-8)
mark(palasi-7, kun-5)
nsubj(palasi-7, hän-6)
</div>

<!-- TODO Attaching punctuation correctly is described more closely in Section [punctspecial](#sec-punctspecial). -->

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/punct.md" target="#">edit punct</a></p>

<h2 id="quantmod-quantification-modifier">quantmod (quantification modifier)</h2>

<p><em>Quantification modifiers</em> (<code>quantmod</code>) are quantifiers that modify a numerical expression. Certain adverbs (and ad-adjectives, which are sometimes regarded a separate category from adverbs but treated identically in TDT)  and few adjectives are allowed as quantifiers. Note that adverbs that describe the writer’s attitude towards the quantity, such as <em>vain</em> (<em>only</em>), are not considered quantification modifiers, but regular adverb modifiers, although they modify the number. Some examples of words that can act as quantification modifiers include <em>noin</em> (<em>about</em>), vähintään (<em>at least</em>), <em>lähes</em> (<em>almost</em>) and <em>yli</em> (<em>over</em>).</p>

<!-- fname:quantmod.pdf -->
<div class="sd-parse">
Alue oli suuruudeltaan noin kymmenen neliökilometriä . \n The_area was of_its_size about ten square_kilometres .
nsubj-cop(neliökilometriä-6, Alue-1)
cop(neliökilometriä-6, oli-2)
nmod(neliökilometriä-6, suuruudeltaan-3)
quantmod(kymmenen-5, noin-4)
num(neliökilometriä-6, kymmenen-5)
punct(neliökilometriä-6, .-7)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/quantmod.md" target="#">edit quantmod</a></p>

<h2 id="rel-relativizer-a-namesec-rela">rel (relativizer) <a name="sec-rel"></a></h2>

<p>The <em>relativizer</em> (<code>rel</code>) is the head of the phrase containing the relative pronoun (or other relative word). Most often, but not always, this is the relative word itself. The governor of the dependency is the main predicate of the relative clause. </p>

<!-- TODO Annotation of relative clauses is more closely examined in Section [relclauses](#sec-relclauses). -->

<!-- fname:rel_basic.pdf -->
<div class="sd-parse">
Auto , joka ohitti meidät , ajoi hyvin nopeasti . \n The_car , which passed us , drove very fast .
rcmod(Auto-1, ohitti-4)
punct(ohitti-4, ,-2)
rel(ohitti-4, joka-3)
dobj(ohitti-4, meidät-5)
punct(ohitti-4, ,-6)
nsubj(ajoi-7, Auto-1)
advmod(ajoi-7, nopeasti-9)
advmod(nopeasti-9, hyvin-8)
punct(ajoi-7, .-10)
</div>

<!-- fname:rel_phrase.pdf -->
<div class="sd-parse">
Nainen , jonka auto hajosi , pyysi apuamme . \n The_lady , whose car broke , asked_for our_help .
rcmod(Nainen-1, hajosi-5)
punct(hajosi-5, ,-2)
poss(auto-4, jonka-3)
rel(hajosi-5, auto-4)
punct(hajosi-5, ,-6)
nsubj(pyysi-7, Nainen-1)
dobj(pyysi-7, apuamme-8)
punct(pyysi-7, .-9)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/rel.md" target="#">edit rel</a></p>

<h2 id="relcl-relative-clause-modifier">relcl (relative clause modifier)</h2>

<p>A <em>relative clause modifier</em> (<code>relcl</code>) marks relative clauses. The governor is the phrase or clause modified, most often a noun phrase but occasionally a full clause as well. The dependent is the main predicate of the relative clause.</p>

<!-- fname:relcl_NP.pdf -->
<div class="sd-parse">
Mies , jonka hän oli nähnyt eilen , oli taas ovella . \n The_man , whom he had seen yesterday , was again at_the_door .
relcl(Mies-1, nähnyt-6)
punct(nähnyt-6, ,-2)
rel(nähnyt-6, jonka-3)
nsubj(nähnyt-6, hän-4)
aux(nähnyt-6, oli-5)
advmod(nähnyt-6, eilen-7)
punct(nähnyt-6, ,-8)
nsubj(oli-9, Mies-1)
advmod(oli-9, taas-10)
nmod(oli-9, ovella-11)
punct(oli-9, .-12)
</div>

<!-- fname:relcl_clause.pdf -->
<div class="sd-parse">
Ovi kolahti auki , mikä säikäytti lapsen . \n The_door clanked open , which scared the_child .
nsubj(kolahti-2, Ovi-1)
advmod(kolahti-2, auki-3)
relcl(kolahti-2, säikäytti-6)
punct(säikäytti-6, ,-4)
rel(säikäytti-6, mikä-5)
dobj(säikäytti-6, lapsen-7)
punct(kolahti-2, .-8)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/relcl.md" target="#">edit relcl</a></p>

<h2 id="remnant">remnant</h2>

<p>The description of the USD relation <code>remnant</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/remnant.md" target="#">edit remnant</a></p>

<h2 id="reparandum">reparandum</h2>

<p>The description of the USD relation <code>reparandum</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/reparandum.md" target="#">edit reparandum</a></p>

<h2 id="root">root</h2>

<p>The description of the USD relation <code>root</code> in Finnish is not yet completed.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/root.md" target="#">edit root</a></p>

<h2 id="vocative-vocative">vocative (vocative)</h2>

<p>The dependency type <code>vocative</code> is used for <em>vocatives</em>, that is, expressions where someone is being addressed. The governor of the dependency is the main predicate of the clause where the addressing occurs.</p>

<!-- fname:voc.pdf -->
<div class="sd-parse">
Pekka , tulisitko tänne ? \n Pekka , would_you_come here ?
vocative(tulisitko-3, Pekka-1)
punct(Pekka-1, ,-2)
advmod(tulisitko-3, tänne-4)
punct(tulisitko-3, ?-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/vocative.md" target="#">edit vocative</a></p>

<h2 id="xcomp-open-clausal-complement-a-namesec-xcompa">xcomp (open clausal complement) <a name="sec-xcomp"></a></h2>

<p>The dependency type <code>xcomp</code> is reserved for clausal complements which have an external subject, that is, whose subject is shared with the complemented verb (phenomenon also known as subject control). Note that the subject of the complementing clause must be the <em>subject</em> of the complemented verb, not any other sentence element.</p>

<!-- fname:xcomp.pdf -->
<div class="sd-parse">
Hän alkoi hakata halkoja . \n He started chopping the_wood .
nsubj(alkoi-2, Hän-1)
xcomp(alkoi-2, hakata-3)
dobj(hakata-3, halkoja-4)
punct(alkoi-2, .-5)
</div>

<p>Many of the complements with an external subject resemble cases that are analyzed as main verbs with auxiliaries. Both auxiliaries and <code>xcomp</code> complements share their subject with another verb, but only a closed list of verbs are analyzed as auxiliaries in TDT (see Section <a href="#sec-aux">aux</a>). Note also that in auxiliary cases the second verb is the governor, whereas with <code>xcomp</code> the first verb becomes governor (unless the word order is inverse).</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_fi/xcomp.md" target="#">edit xcomp</a></p>



<!-- "relation in other languages" links -->
<hr/>
























































































































































      </div>

<script type="text/javascript">
//    var bratLocation = 'http://weaver.nlplab.org/~brat/demo/v1.3';
    var bratLocation = 'http://weaver.nlplab.org/~brat/demo/master';
    head.js(
        // External libraries
        bratLocation + '/client/lib/jquery.min.js',
        bratLocation + '/client/lib/jquery.svg.min.js',
        bratLocation + '/client/lib/jquery.svgdom.min.js',
	bratLocation + '/client/lib/jquery-ui.min.js',

        // brat helper modules
        bratLocation + '/client/src/configuration.js',
        bratLocation + '/client/src/util.js',
        bratLocation + '/client/src/annotation_log.js',
        bratLocation + '/client/lib/webfont.js',
        // brat modules
        bratLocation + '/client/src/dispatcher.js',
        bratLocation + '/client/src/url_monitor.js',
        bratLocation + '/client/src/visualizer.js'
    );

    var webFontURLs = [
//        bratLocation + '/static/fonts/Astloch-Bold.ttf',
        bratLocation + '/static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        bratLocation + '/static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var collData = {
	'entity_types': [
// this is optional
        {
            'type': 'SPAN_DEFAULT',
            'bgColor': '#7fa2ff',
            'borderColor': 'darken'
        },
        {
            'type': 'token',
            'labels': [ '\u00A0\u00A0' ], // non-breaking space for empty
        }
	],
	'entity_attribute_types': [],
	'relation_types': [
// this is optional
//         {
//             'type': 'subj',
//             'labels': [ 'subj' ],
//             'dashArray': '3,3',
//             'color': 'green',
//             'args': [
//                 {
//                     'role': 'arg1',
//                     'targets': [ 'token' ]
//                 },
//                 {
//                     'role': 'arg2',
//                     'targets': [ 'token' ]
//                 }
//             ]
//         }
        ],
	'event_types': [],
    };

    var normalizeSpace = function(s) {
	s = s.replace(/^\s+/, '');
	s = s.replace(/\s+$/, '');
	s = s.replace(/\s\s+/g, ' ');
	return s;
    };

    var compactJSON = function(s) {
        // remove (some) space from JSON string, giving a visually
        // more compact (but equivalent and still pretty-printed)
        // version.

        if (s === undefined) {
            return s;
        }

	// replace any space with ' ' in non-nested curly brackets
	s = s.replace(/(\{[^\{\}\[\]]*\})/g, 
		      function(a, b) { return b.replace(/\s+/g, ' '); });
	// replace any space with ' ' in [] up to nesting depth 1
// 	s = s.replace(/(\[(?:[^\[\]\{\}]|\[[^\[\]\{\}]*\])*\])/g, 
// 		      function(a, b) { return b.replace(/\s+/g, ' '); });
	// actually, up to nesting depth 2
	s = s.replace(/(\[(?:[^\[\]\{\}]|\[(?:[^\[\]\{\}]|\[[^\[\]\{\}]*\])*\])*\])/g, 
		      function(a, b) { return b.replace(/\s+/g, ' '); });
	return s
    };

    var objectToString = function(data) {
	return compactJSON(JSON.stringify(data, undefined, '    '));
    };

    var parseToken = function(token) {
	// return [text, POS] for token encoded as "text/POS", or
	// [text, "token"] if no POS (/-separated string) is included.
	var text, POS;

	m = token.match(/((?:[^\\]|\\.)+)\/(.+)$/);
	if (!m) {
	    text = token, POS = 'token';
	} else {
	    text = m[1], POS = m[2];
	}

	// apply defined backslash escape sequences
	text = text.replace(/((?:[^\\]+|\\.)*?)\\n/g, '$1\n');

	// unescape backslash escapes in text and tag
	text = text.replace(/([^\\]*)\\(.)/g, '$1$2');
	POS = POS.replace(/([^\\]*)\\(.)/g, '$1$2');

	return [text, POS];
    };

    // helper for *parse functions
    var makeLogger = function(logElement) {
        return function(s) {
	    if (logElement === undefined) {
		console.log(s);
	    } else {
		logElement.val(logElement.val() + s + '\n');
	    }
	};
    };

    // parse SD format, return brat document data format
    var parseSd = function(sd, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = sd.split('\n');

	// first line is assumed to be sentence text
	var sentence_text = lines[0];
	sentence_text = normalizeSpace(sentence_text);

	// determine token offsets and construct spans ("entities")
	var tokens = sentence_text.split(' '),
            spans = [],
            offset = 0,
            error = false;
	sentence_text = '';
	for (var i=0; i<tokens.length; i++) {
	    var text_POS = parseToken(tokens[i]);
	    var text = text_POS[0], POS = text_POS[1];
	    var length = text.length;
	    if (!text.match(/^\s*$/)) { // skip space-only (e.g. newline)
		spans.push(['T'+(i+1), POS, [[offset, offset+length]]]);
		tokens[i] = text;
	    }
	    offset += length + 1;
	    sentence_text += text + ' ';
	}

	var tokenIndex = function(t) {
	    // accept two formats: indexed ('dog-1') and simple ('dog')
	    // TODO: consider case-insensitive implementation

	    // indexed match
	    var m = t.match(/^\s*(.*)-(\d+)\s*$/)	      
	    if (m) {
		var text = m[1], idx = m[2];
		// confirm match (SD indices are 1-based)
		idx = parseInt(idx, 10) - 1;
		if (tokens[idx] === text) {
		    return idx;
		} else {
		    // TODO consider skipping output, not necessarily an error
		    log('token text mismatch: "'+text+'" vs. "'+tokens[idx]+'"');
		}
		// fall through to allow simple match for e.g. 'il-2'
	    }

	    // simple match
	    var firstIdx = $.inArray(t, tokens);
	    if (firstIdx === -1) {
		return null;
	    } else {
		if ($.inArray(t, tokens, firstIdx+1) !== -1) {
		    log('warning: multiple occurrences of "'+t+'"');
		}
		return firstIdx;
	    }
	};

	// parse lines after the first as dependencies, construct relations
	var relations = [];
	for (var i=1; i<lines.length; i++) {
	    var line = lines[i];
	    line = normalizeSpace(line);
	    
	    if (line.match(/^\s*$/)) {
		continue; // ignore empties
	    }
	    
	    var m = line.match(/^(\S+)\s*\(\s*(\S+)\s*,\s*(\S+)\s*\)$/);
	    if (!m) {
		log('failed to parse: "'+line+'"');
		error = true;
		continue;
	    }
	    var type = m[1], from = m[2], to = m[3];
	    
	    // determine which tokens are referred to
	    var fromIdx = tokenIndex(from), toIdx = tokenIndex(to);
	    if (fromIdx === null || toIdx === null) {
		log('failed to find token: "'+line+'"');
		error = true;
		continue;
	    }
	    
	    relations.push([ 'R'+i, type, [ [ 'arg1', 'T'+(fromIdx+1) ], 
					    [ 'arg2', 'T'+(toIdx+1)   ] ] ]);
	}

	log('SD parse done: '+spans.length+' tokens, '+relations.length+' dependencies.');
          
	return {
	    'text': sentence_text,
	    'entities' : spans,
            'relations' : relations,
	    'error' : error
	};
    };

    // parse CoNLL-X format, return brat document data format
    var parseConllX = function(conll, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = conll.split('\n');

        // each line has the following format
        // (from https://code.google.com/p/clearparser/wiki/DataFormat):
        //
        //     ID: token counter, starting at 1 for each new sentence
        //     FORM: word form or punctuation symbol
        //     LEMMA: lemma or stem of word form
        //     POSTAG: fine-grained part-of-speech tag
        //     FEATS: extra features ('_' indicates no extra feature)
        //     HEAD: head ID of the current token
        //     DEPREL: dependency relation to the HEAD
        // 
        // (here, we will use ID, FORM, POSTAG, HEAD and DEPREL)
        var ids = [],
            forms = [],
            postags = [],
            heads = [],
            deprels = [],
            error = false;
        for (var i=0; i<lines.length; i++) {
            var line = lines[i];
            line = line.replace(/\s$/, '');
            var fields = line.split(/\s+/);
            //var fields = line.split(/\t/);
            if (fields.length === 8) {
                ids.push(fields[0]);
                forms.push(fields[1]);
                postags.push(fields[4]);
                heads.push(fields[6]);
                deprels.push(fields[7]);
            } else {
                // TODO: better error handling
                log('expected 8 fields, got '+fields.length+': "'+line+'"');
		error = true;
		continue;
            }
        }

	var spans = [],
            relations = [],
            offset = 0;
	for (i=0; i<ids.length; i++) {
	    var length = forms[i].length;
	    spans.push(['T'+ids[i], postags[i], [[offset, offset+length]]]);
            offset += length + 1;
	    // TODO: handle root
	    if (heads[0] === 0) {
                continue;
	    }
            relations.push(['R'+ids[i], deprels[i], 
			    [ [ 'arg1', 'T'+heads[i] ],
			      [ 'arg2', 'T'+ids[i] ] ] ]);
        }

        var text = forms.join(' ');

	return {
	    'text': text,
	    'entities' : spans,
            'relations' : relations,
	    'error' : error
	};
    };

    // from http://stackoverflow.com/a/2117523
    var random_guid = function() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    };

    // add prefix and suffix to all IDs in data, modifying data. If neither a prefix
    // nor suffix is provided, add a random GUID prefix.
    var reviseIds = function(data, prefix, suffix) {
        if (prefix === undefined) {
            prefix = '';
        }
        if (suffix === undefined) {
            suffix = '';
        }
        if (prefix === '' && suffix == '') {
            // no prefix or suffix defined: generate random GUID prefix
            prefix = random_guid() + '-';
        }

        // entities: entity ID only
	var entities = data['entities'];
	for (var i=0; i<entities.length; i++) {
            entities[i][0] = prefix + entities[i][0] + suffix;
        }

        // relations: relation ID and argument IDs
        var relations = data['relations'];
        for (var i=0; i<relations.length; i++) {
            relations[i][0] = prefix + relations[i][0] + suffix;
            var args = relations[i][2];
            for (var j=0; j<args.length; j++) {
                args[j][1] = prefix + args[j][1] + suffix;
            }
            console.log(relations[i]);
        }

        // TODO: events, equivs, etc.

        return data;
    };

    var embeddedIdSeq = 1;

    var embedAnnotation = function(elem, parse, data, options) {
	// store sequence number for reference resolution
	elem.attr('embeddedSequenceNum', embeddedIdSeq);

	var eId = 'embedded-' + embeddedIdSeq++,
            inputTabId = eId + '-2',
            bratTabId = eId + '-3',
            infoTabId = eId + '-4';

	// visualization and related data elements
	var visDiv = $('<div id="'+eId+'-vis"></div>');
	var tabDiv = $('<div id="'+eId+'-tabs"></div>');
	var shDiv  = $('<div id="'+eId+'-sh" class="show-hide-div"></div>');
	var showHideButton = $('<button id="'+eId+'-toggle" '+
			       'class="show-hide-toggle">hide</button>');
	shDiv.append(showHideButton);

	var inputArea = $('<textarea id="'+eId+'-in" ' +
			  'class="embedded-brat-data"></textarea>');
	var bratArea = $('<textarea id="'+eId+'-brat" disabled="disabled" ' +
			 'class="embedded-brat-data"></textarea>');
	var logArea = $('<textarea id="'+eId+'-log" disabled="disabled" ' +
			'class="embedded-brat-data"></textarea>');

	// initialize parse function, falling back to SD as default
	if (parse === undefined) {
	    parse = parseSd;
	}

	// initialize data, defaulting to original element text
	if (data === undefined) {
	    data = elem.text();
	}
	data = normalizeSpace(data);
	var parsed = parse(data, makeLogger(logArea));
        parsed = reviseIds(parsed, eId + '-');
	inputArea.text(data);
	bratArea.text(objectToString(parsed));

        // initialize options, falling back to attributes as defaults
        if (options === undefined) {
            options = {};
        }
        $.each(elem[0].attributes, function(idx) {
            var name = this.name;
            var value = this.value;
            // ignore standard attributes and options provided by caller
            var standardAttr = ['id', 'class', 'embeddedsequencenum'];
            if ($.inArray(name.toLowerCase(), standardAttr) === -1 &&
                options[name] === undefined) {
                options[name] = value;
            }
	});
				      
	// build top-level structure
	elem.empty();
	// tab headers (li+a)
	tabDiv.append([
		       '<div id="'+eId+'">',
		       '  <ul>',
		       '    <li><a href="#'+inputTabId+'">input</a></li>',
		       '    <li><a href="#'+bratTabId+'">brat</a></li>',
		       '    <li><a href="#'+infoTabId+'">info</a></li>',
		       '  </ul>',
		       '</div>'
		       ].join('\n'));
	// tab content (divs)
	var inputTab   = $('<div id="'+inputTabId+'"></div>'),
            bratTab = $('<div id="'+bratTabId+'"></div>'),
            logTab  = $('<div id="'+infoTabId+'"></div>');
	inputTab.append(inputArea);
	bratTab.append(bratArea);
	logTab.append(logArea);

	// add content to top-level element, turn into jQuery-ui tabs
	tabDiv.append(inputTab, bratTab, logTab);
	elem.append(shDiv, tabDiv, visDiv);
	tabDiv.tabs();
	var shVisible = 0;
	var setShToggleText = function() {
	    $('span', showHideButton).text(shVisible ? 'hide' : 'edit');
	}
	tabDiv.hide(); // TODO make optional (control e.g. using class)
        showHideButton.button().click(function(ev) {
	   tabDiv.toggle('blind');
	   shVisible = !shVisible;
	   setShToggleText();
	});
	setShToggleText();

        // only show tabs / tab visibility control if set in options
        if (options && !options.tabs) {
            showHideButton.hide();
            tabDiv.hide();
        }

	// initialize brat visualization
        var dispatcher = Util.embed(eId+'-vis',
          $.extend({'collection': null}, collData),
          $.extend({}, parsed), webFontURLs);

	// hook everything up
        var renderError = function() {
            bratArea.css({'border': '2px solid red'});
        };
        dispatcher.on('renderError: Fatal', renderError);

        var inputHandler = function() {
            var parsed, parse_error = false;

	    logArea.val(''); // clear log

            try {
                parsed = parse(inputArea.val(), makeLogger(logArea));
                parsed = reviseIds(parsed, embeddedIdSeq + '-');
		parse_error = parsed.error;
            } catch (e) {
		console.log(e);
		parse_error = true;
            }

	    // console.log(parse_error);

	    if (!parse_error) {
                inputArea.css({'border': '2px inset'});
	    } else {
                inputArea.css({'border': '2px solid red'});
                return;
	    }
    
	    bratArea.text(objectToString(parsed));

            try {
                dispatcher.post('requestRenderData', [$.extend({}, parsed)]);
                bratArea.css({'border': '2px inset'});
            } catch(e) {
		console.log('requestRenderData error:', e);
		logArea.append('requestRenderData error: '+e);
                bratArea.css({'border': '2px solid red'});
            }
        };
        inputArea.bind('propertychange keyup input paste', inputHandler);
    };

    var resolveEmbeddedReference = function(elem, data) {
	var refId = elem.attr('href'),
	    refElem = $(refId);
	
	if (refElem === undefined) {
	    console.log('Failed to resolve reference to', refId, 'for', elem);
	    return;
	}

	var refSeq = refElem.attr('embeddedSequenceNum');
	if (refSeq === undefined) {
	    console.log('no embeddedSequenceNum for', refElem);
	    return;
	}

	var origText = elem.text();
	var resolvedText = origText.replace(/\#/, refSeq);
	if (origText === resolvedText) {
	    console.log('failed replace in text', origText, 'for', elem);
	    return;
	}

	elem.text(resolvedText);
    };

    var embedBratVisualizations = function() {
        // generate embedded visualizations: call embedAnnotation
	// for elements with "sd-parse" class.
        $('.sd-parse').each(function(idx) {
            embedAnnotation($(this), parseSd);
	});

        // repeat for elements with "conllx-parse" class.
        $('.conllx-parse').each(function(idx) {
            embedAnnotation($(this), parseConllX);
	});

	// resolve references (e.g. "Figure #" -> "Figure 1"): call
	// resolveEmbeddedReference for elements with "embed-ref" class.
	$('.embed-ref').each(function(idx) {
            resolveEmbeddedReference($(this));
	});
    };

    head.ready(function() {
	// just call this in head.ready()
	embedBratVisualizations();
    });
</script>


      <div id="footer">
          <p class="footer-text">embedded brat &copy; 2010-2014 the <a href="http://brat.nlplab.org/about.html" style="color:gray">brat contributors</a></p>
      </div>
    </div>
  </body>
</html>
