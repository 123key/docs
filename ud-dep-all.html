

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-GB" xml:lang="en-GB" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>Universal Dependencies</title>
    <link rel="root" href=""/> <!-- for JS -->
    <link rel="stylesheet" type="text/css" href="css/jquery-ui-redmond.css"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <link rel="stylesheet" type="text/css" href="http://weaver.nlplab.org/~brat/demo/v1.3/style-vis.css"/>
    <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/headjs/1.0.3/head.min.js"></script>
<!--     <link rel="shortcut icon" href="favicon.ico"/> -->
  </head>
  <body>
    <div id="main" class="center">

      <div id="hp-header">
          <span class="header-text"><a href="http://universaldependencies.github.io/docs/">home</a></span>

          <span class="header-text"><a href="https://github.com/universaldependencies/docs/issues">issue tracker</a></span>
      </div>

      <hr/>

      <div id="content">
	<noscript>
	  <div id="noscript">
	    It appears that you have Javascript disabled.
	    Please consider enabling Javascript for this page to see the visualizations.
	  </div>
	</noscript>

          <p>The following table is adapted from <em>Universal Stanford Dependencies:
A cross-linguistic typology</em> (de Marneffe <em>et al.</em> 2014).</p>

<table class="typeindex">
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Core dependents of clausal predicates</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/nsubj.html">nsubj</a></td>
	  <td><a href="ud-dep/csubj.html">csubj</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/nsubjpass.html">nsubjpass</a></td>
	  <td><a href="ud-dep/csubjpass.html">csubjpass</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/dobj.html">dobj</a></td>
	  <td><a href="ud-dep/ccomp.html">ccomp</a></td>
	  <td><a href="ud-dep/xcomp.html">xcomp</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/iobj.html">iobj</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Non-core dependents of clausal predicates</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a href="ud-dep/advcl.html">advcl</a></td>
	  <td><a href="ud-dep/advmod.html">advmod</a></td>
	</tr>
	<tr>
	  <td>&nbsp;</td>
	  <td><a href="ud-dep/nfincl.html">nfincl</a></td>
	  <td><a href="ud-dep/neg.html">neg</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/nmod.html">nmod</a></td>
	  <td><a href="ud-dep/ncmod.html">ncmod</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Special clausal dependents</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Auxiliary</i></td>
	  <td><i>Other</i></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/vocative.html">vocative</a></td>
	  <td><a href="ud-dep/aux.html">aux</a></td>
	  <td><a href="ud-dep/mark.html">mark</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/discourse.html">discourse</a></td>
	  <td><a href="ud-dep/auxpass.html">auxpass</a></td>
	  <td><a href="ud-dep/punct.html">punct</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/expl.html">expl</a></td>
	  <td><a href="ud-dep/cop.html">cop</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Noun dependents</b></td></tr>
	<tr>
	  <td><i>Nominal dep</i></td>
	  <td><i>Predicate dep</i></td>
	  <td><i>Modifier word</i></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/nummod.html">nummod</a></td>
	  <td><a href="ud-dep/relcl.html">relcl</a></td>
	  <td><a href="ud-dep/amod.html">amod</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/appos.html">appos</a></td>
	  <td><a href="ud-dep/nfincl.html">nfincl</a></td>
	  <td><a href="ud-dep/det.html">det</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/nmod.html">nmod</a></td>
	  <td><a href="ud-dep/ncmod.html">ncmod</a></td>
	  <td><a href="ud-dep/neg.html">neg</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Compounding and unanalyzed</b></td></tr>
	<tr>
	  <td><a href="ud-dep/compound.html">compound</a></td>
	  <td><a href="ud-dep/mwe.html">mwe</a></td>
	  <td><a href="ud-dep/goeswith.html">goeswith</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/name.html">name</a></td>
	  <td><a href="ud-dep/foreign.html">foreign</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Coordination</b></td></tr>
	<tr>
	  <td><a href="ud-dep/conj.html">conj</a></td>
	  <td><a href="ud-dep/cc.html">cc</a></td>
	</tr>
      </table>

    </td>
  </tr>
  <tr>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Case-marking, prepositions, possessive</b></td></tr>
	<tr>
	  <td><a href="ud-dep/case.html">case</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Loose joining relations</b></td></tr>
	<tr>
	  <td><a href="ud-dep/list.html">list</a></td>
	  <td><a href="ud-dep/parataxis.html">parataxis</a></td>
	  <td><a href="ud-dep/remnant.html">remnant</a></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/dislocated.html">dislocated</a></td>
	  <td></td><td><a href="ud-dep/reparandum.html">reparandum</a></td>
	</tr>
      </table>

    </td>
    <td>

      <table class="category">
	<tr><td colspan="3"><b>Other</b></td></tr>
	<tr>
	  <td><i>Sentence head</i></td>
	  <td colspan="2"><i>Unspecified dependency</i></td>
	</tr>
	<tr>
	  <td><a href="ud-dep/root.html">root</a></td>
	  <td><a href="ud-dep/dep.html">dep</a></td>
	</tr>
      </table>

    </td>
  </tr>
</table>

<p>Note: <i>nmod</i>, <i>ncmod</i>, <i>nfincl</i>, and <i>neg</i> appear
in two places.</p>

<hr />

<h2 id="advcl-adverbial-clause-modifier">advcl: adverbial clause modifier</h2>

<p>An adverbial clause modifier is a clause which modifies a verb or other predicate (adjective, etc.), as a modifier not as a core complement. This includes things such as a temporal clause, consequence, conditional clause, purpose
clause, etc. The dependent must be clausal (or else it is an advmod) and the dependent is the main predicate of the clause.</p>

<div class="sd-parse">
The accident happened as night was falling
advcl(happened, falling)
</div>

<div class="sd-parse">
If you know who did it, you should tell the teacher
advcl(tell, know)
</div>

<div class="sd-parse">
He talked to him in order to secure the account
advcl(talked, secure)
</div>

<div class="sd-parse">
He was upset when I talked to him
advcl(upset, talked)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/advcl.md" target="#">edit advcl</a></p>

<h2 id="advmod-adverbial-modifier">advmod: adverbial modifier</h2>

<p>An adverbial modifier of a word is a (non-clausal) adverb or adverbial
phrase (ADVP) that serves to modify the meaning of the word.</p>

<div class="sd-parse">
Genetically modified food
advmod(modified, Genetically)
</div>

<div class="sd-parse">
less often
advmod(often, less)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/advmod.md" target="#">edit advmod</a></p>

<h2 id="amod-adjectival-modifier">amod: adjectival modifier</h2>

<p>An adjectival modifier of an NP is any adjectival phrase that serves
to modify the meaning of the NP.</p>

<div class="sd-parse">
Sam eats red meat
amod(meat, red)
</div>

<div class="sd-parse">
Sam took out  a 3 million dollar loan
amod(loan, dollar)
</div>

<div class="sd-parse">
Sam took out  a $ 3 million loan
amod(loan, $)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/amod.md" target="#">edit amod</a></p>

<h2 id="appos-appositional-modifier">appos: appositional modifier</h2>

<p>An appositional modifier of an NP is an NP immediately to the right of
the first NP that serves to define or modify that NP. It includes
parenthesized examples, as well as defining abbreviations in one of
these structures.</p>

<div class="sd-parse">
Sam , my brother , arrived
appos(Sam-1, brother-4)
</div>

<div class="sd-parse">
Bill ( John 's cousin )
appos(Bill-1, cousin-5)
</div>

<div class="sd-parse">
The Australian Broadcasting Corporation ( ABC )
appos(Corporation-4, ABC-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/appos.md" target="#">edit appos</a></p>

<h2 id="aux-auxiliary">aux: auxiliary</h2>

<p>An auxiliary of a clause is a non-main verb of the clause, e.g., a
modal auxiliary, or a form of “be”, “do” or “have” in a periphrastic
tense.</p>

<div class="sd-parse">
Reagan has died
aux(died-3, has-2)
</div>

<div class="sd-parse">
He should leave
aux(leave-3, should-2)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/aux.md" target="#">edit aux</a></p>

<h2 id="auxpass-passive-auxiliary">auxpass: passive auxiliary</h2>

<p>A passive auxiliary of a clause is a non-main verb of the clause which
contains the passive information.</p>

<div class="sd-parse">
Kennedy has been killed
auxpass(killed, been)
</div>

<div class="sd-parse">
Kennedy was killed
auxpass(killed, was)
</div>

<div class="sd-parse">
Kennedy got killed
auxpass(killed, got)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/auxpass.md" target="#">edit auxpass</a></p>

<h2 id="case-case-marking">case: case marking</h2>

<p>The <em>case</em> relation is used for any case-marking element (including prepositions, postpositions, and clitic case markers). Case-marking elements are treated as dependents of the noun or clause it attaches to or introduces. Thus, contrary to SD, USD abandons treating a preposition as a mediator between a modified word and its object. The <em>case</em> relation aims at providing a uniform analysis of prepositions and case in morphologically rich languages.</p>

<div class="sd-parse">
the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</div>

<div class="sd-parse">
the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</div>

<p>French:
&lt;div class="sd-parse"&gt;
le bureau du président \n the office of the_Chair
det(bureau, le)
nmod(bureau, président)
case(président, du)
&lt;/div&gt;</p>

<p>Hebrew:
&lt;div class="sd-parse"&gt;
wkfraiti/VERB at/PRT-ACC hsrj/NOUN \n and_when_I_saw ACC the_movie
dobj(wkfraiti-1, hsrj-3)
case(hsrj-3, at-2)
&lt;/div&gt;</p>

<p>When case markers are morphemes, they are not divided off the noun as a separate case dependent, but the noun as a whole is analyzed as a <em>nmod</em> of the verb. To overtly mark case, POS tags are included in the representation as shown below on a Russian example. We use the universal POS tagset from Petrov et al. (2012) to which we append case information.</p>

<div class="sd-parse">
Ya/NOUN-NOM napisal/VERB pis'mo/NOUN-ACC perom/NOUN-INSTR \n I wrote the_letter with_a_quill
nsubj(napisal-2, Ya-1)
dobj(napisal-2, pis'mo-3)
nmod(napisal-2, perom-4)
</div>

<p>This treatment provides parallelism between different constructions
across and within languages. A good result is that we now have greater
parallelism between prepositional phrases and subordinate clauses,
which are in practice often introduced by a preposition:</p>

<div class="sd-parse">
Sue left after the rehearsal
nsubj(left-2, Sue-1)
nmod(left-2, rehearsal-5)
det(rehearsal-5, the-4)
case(rehearsal-5, after-3)
</div>

<div class="sd-parse">
Sue left after we did
nsubj(left-2, Sue-1)
advcl(left-2, did-5)
mark(did-5, after-3)
nsubj(did-5, we-4)
</div>

<p>We also obtain parallel constructions for</p>

<ul>
  <li>the possessive alternation</li>
</ul>

<div class="sd-parse">
the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</div>

<div class="sd-parse">
the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</div>

<ul>
  <li>variant forms with case, a preposition or a
postposition in Finnish</li>
</ul>

<div class="sd-parse">
etsiä ilman johtolankaa \n to_search without clue.PARTITIVE
nmod(etsiä, johtolankaa)
case(johtolankaa, ilman)
</div>

<div class="sd-parse">
etsiä taskulampun kanssa \n to_search torch.GENITIVE with
nmod(etsiä, taskulampun)
case(taskulampun, kanssa)
</div>

<div class="sd-parse">
etsiä johtolangatta \n to_search clue.ABESSIVE
nmod(etsiä, johtolangatta)
</div>

<ul>
  <li>the dative alternation where the prepositional construction gets a similar
analysis to the double object construction</li>
</ul>

<div class="sd-parse">
give the children the toys
dobj(give, toys)
iobj(give, children)
</div>

<div class="sd-parse">
give the toys to the children
dobj(give, toys)
nmod(give, children)
case(children, to)
</div>

<div class="sd-parse">
donner les_jouets aux enfants \n give the_toys to_the children
dobj(donner-1, les_jouets-2)
nmod(donner-1, enfants-4)
case(enfants-4, aux-3)
</div>

<p>Another advantage of this new analysis is that it provides a treatment
of prepositional phrases that are predicative complements of “be” that is consistent with the treatment of nominal predicative
complements:</p>

<div class="sd-parse">
Sue is in shape
nsubj(shape-4, Sue-1)
cop(shape-4, is-2)
case(shape-4, in-3)
</div>

<p>Stacked prepositions, such as <em>out of</em> are regarded as some form of <em>mwe</em>:</p>

<div class="sd-parse">
Out of all this , something good will come.
</div>

<div class="sd-parse">
Out of all this ... come
mwe(Out-1, of-2)
predet(this-4, all-3)
case(this-4, Out-1)
nmod(come-6, this-4)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/case.md" target="#">edit case</a></p>

<h2 id="cc-coordination">cc: coordination</h2>

<p>A coordination is the relation between an element of a conjunct and
the coordinating conjunction word of the conjunct.  (Note: different
dependency grammars have different treatments of coordination.  We
take one conjunct of a conjunction (normally the first) as the head of
the conjunction.) A conjunction may also appear at the beginning of a
sentence.  This is also called a cc, and it depends on the root
predicate of the sentence.</p>

<div class="sd-parse">
And then we left .
cc(left, And)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/cc.md" target="#">edit cc</a></p>

<h2 id="ccomp-clausal-complement">ccomp: clausal complement</h2>

<p>A clausal complement of a verb or adjective is a dependent clause with
an internal subject which functions like an object of the verb, or
adjective.  Clausal complements for nouns are limited to complement
clauses with a subset of nouns like “fact” or “report”.  We analyze
them the same (parallel to the analysis of this class as “content
clauses” in Huddleston and Pullum 2002). Such clausal complements are
usually finite (though there are occasional remnant English
subjunctives).</p>

<div class="sd-parse">
He says that you like to swim
ccomp(says, like)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/ccomp.md" target="#">edit ccomp</a></p>

<p><em>compound</em> is one of the three relations in USD for compounding.</p>

<p>It is used for </p>

<ul>
  <li>any kind of X<sup>0</sup> compounding: noun compounds (e.g., <em>phone book</em>), but also verb and
adjective compounds that are more common in other languages (such as
Persian or Japanese light verb constructions)</li>
</ul>

<div class="sd-parse">
Phone book
compound(book, Phone)
</div>

<ul>
  <li>for numbers</li>
</ul>

<div class="sd-parse">
I have four thousand sheep
compound(thousand, four)
</div>

<div class="sd-parse">
I lost $ 3.2 billion
compound(billion, 3.2)
</div>

<ul>
  <li>for particles of phrasal verbs:</li>
</ul>

<div class="sd-parse">
put up
compound(put, up)
</div>

<p>The two other compounding relations are:</p>

<ul>
  <li>
    <p><em>mwe</em> for fixed grammaticized expressions with function words (e.g., <em>instead of</em>:
<em>mwe</em>(of,instead), Fr. plutôt que “rather than”: <em>mwe</em>(que,plutôt))</p>
  </li>
  <li>
    <p><em>name</em> for proper nouns constituted of multiple nominal elements</p>
  </li>
</ul>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/compound.md" target="#">edit compound</a></p>

<h2 id="conj-conjunct">conj: conjunct</h2>

<p>A conjunct is the relation between two elements connected by a
coordinating conjunction, such as “and”, “or”, etc.  We treat
conjunctions asymmetrically: The head of the relation is the first
conjunct and other conjunctions depend on it via the <em>conj</em> relation.</p>

<div class="sd-parse">
Bill is big and honest
conj(big, honest)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/conj.md" target="#">edit conj</a></p>

<h2 id="cop-copula">cop: copula</h2>

<p>A copula is the relation between the complement of a copular verb and
the copular verb.  (We normally take a copula as a dependent of its
complement)</p>

<div class="sd-parse">
Bill is an honest man
cop(man, is)
</div>

<div class="sd-parse">
Ivan is the best dancer
nsubj(dancer-5, Ivan-1)
cop(dancer-5, is-2)
det(dancer-5, the-3)
amod(dancer-5, best-4)
</div>

<p>The copula “be” are not treated as the
head of a clause, but rather the dependent of a lexical predicate, as exemplified above.</p>

<p>Such an analysis is motivated by the fact that many languages
often or always lack an overt copula in such constructions, as in the
the following Russian example:</p>

<div class="sd-parse">
Ivan lučšij tancor \n Ivan best dancer
nsubj(tancor, Ivan)
amod(tancor, lučšij)
</div>

<p>Similar constructions arise even in English if we
consider so-called raising-to-object or small clause constructions.
Under the basic analysis proposed for SD, the predicate complement is
not linked to its subject argument, but in the enhanced representation
(see below), the linkage is then parallel to the treatment in a zero
copula language:</p>

<div class="sd-parse">
I judge Ivan the best dancer
nsubj(judge-2, I-1)
dobj(judge-2, Ivan-3)
xcomp(judge-2, dancer-6)
det(dancer-6, the-4)
amod(dancer-6, best-5)
nsubj(dancer-6, Ivan-3)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/cop.md" target="#">edit cop</a></p>

<h2 id="csubj-clausal-subject">csubj: clausal subject</h2>

<p>A clausal subject is a clausal syntactic subject of a clause, i.e.,
the subject is itself a clause. The governor of this relation might
not always be a verb: when the verb is a copular verb, the root of the
clause is the complement of the copular verb. In the two following
examples, “what she said” is the subject.</p>

<div class="sd-parse">
What she said makes sense
csubj(makes, said)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/csubj.md" target="#">edit csubj</a></p>

<h2 id="csubjpass-clausal-passive-subject">csubjpass: clausal passive subject</h2>

<p>A clausal passive subject is a clausal syntactic subject of a passive
clause. In the example below, “that she lied” is the subject.</p>

<div class="sd-parse">
That she lied was suspected by everyone
csubjpass(suspected, lied)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/csubjpass.md" target="#">edit csubjpass</a></p>

<h2 id="dep-unspecified-dependency">dep: unspecified dependency</h2>

<p>A dependency is labeled as <em>dep</em> when the system is unable to
determine a more precise dependency relation between two words.  This
may be because of a weird grammatical construction, a limitation in
the Stanford Dependency conversion software, a parser error, or
because of an unresolved long distance dependency.</p>

<div class="sd-parse">
Then , as if to show that he could , ...
dep(show, if)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/dep.md" target="#">edit dep</a></p>

<h2 id="det-determiner">det: determiner</h2>

<p>A determiner is the relation between the head of an NP and its
determiner.</p>

<div class="sd-parse">
The man is here
det(man, The)
</div>

<div class="sd-parse">
Which book do you prefer ?
det(book, Which)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/det.md" target="#">edit det</a></p>

<h2 id="discourse-discourse-element">discourse: discourse element</h2>

<p>This is used for interjections and other discourse particles and
elements (which are not clearly linked to the structure of the
sentence, except in an expressive way). We generally follow the
guidelines of what the Penn Treebanks count as an INTJ.  They define
this to include: interjections (<em>oh</em>, <em>uh-huh</em>, <em>Welcome</em>), fillers
(<em>um</em>, <em>ah</em>), and discourse markers (<em>well</em>, <em>like</em>, <em>actually</em>, but
not <em>you know</em>).</p>

<div class="sd-parse">
Iguazu is in Argentina :)
discourse(is-2, :)-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/discourse.md" target="#">edit discourse</a></p>

<h2 id="dislocated-dislocated-elements">dislocated: dislocated elements</h2>

<p>The <em>dislocated</em> relation is used for fronted or postposed elements that do not fulfill the usual core grammatical relations of a sentence. </p>

<p>It is used for fronted elements that introduce the topic of a sentence, as in the following Japanese example:</p>

<div class="sd-parse">
象 は 鼻 が 長い \n zoo wa hana ga naga-i \n elephant TOPIC nose SUBJ long-PRES
dislocated(長い-5, 象-1)
</div>

<p>However, it would not be used for a topic-marked noun that is also the subject of the sentence; this would be an nsubj.</p>

<p>It is also used for postposed elements. Right dislocated elements are frequent in spoken languages: e.g., French:</p>

<div class="sd-parse">
Il faut pas la manger, la plasticine \n must not it eat the playdough
dobj(manger,-5, la-4)
dislocated(faut-2, plasticine-7)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/dislocated.md" target="#">edit dislocated</a></p>

<h2 id="dobj-direct-object">dobj: direct object</h2>

<p>The direct object of a VP is the noun phrase which is the (accusative)
object of the verb.</p>

<div class="sd-parse">
She gave me a raise
dobj(gave, raise)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/dobj.md" target="#">edit dobj</a></p>

<h2 id="expl-expletive">expl: expletive</h2>

<p>This relation captures an existential “there”. The main verb of the
clause is the governor.</p>

<div class="sd-parse">
There is a ghost in the room
expl(is, There)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/expl.md" target="#">edit expl</a></p>

<h2 id="foreign-foreign-words">foreign: foreign words</h2>

<p>We use <em>foreign</em> to label sequences of foreign words. These are given
a linear analysis: the head is the left-most token in the foreign phrase.</p>

<div class="sd-parse">
I guess that c' est la vie
nsubj(guess-2, I-1)
ccomp(guess-2, c'-4)
mark(c'-4, that-3)
foreign(c'-4, est-5)
foreign(c'-4, la-6)
foreign(c'-4, vie-7)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/foreign.md" target="#">edit foreign</a></p>

<h2 id="goeswith-goes-with">goeswith: goes with</h2>

<p>This relation links two parts of a word that are separated in text
that is not well edited. We follow the treebank: The GW part is the
dependent and the head is in some sense the “main” part, often the
second part.</p>

<div class="sd-parse">
They come here with out legal permission
goeswith(out-5, with-4)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/goeswith.md" target="#">edit goeswith</a></p>

<h2 id="iobj-indirect-object">iobj: indirect object</h2>

<p>The indirect object of a VP is the noun phrase which is the (dative)
object of the verb.</p>

<div class="sd-parse">
She gave me a raise
iobj(gave, me)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/iobj.md" target="#">edit iobj</a></p>

<h2 id="list-list">list: list</h2>

<p>The <em>list</em> relation is used for chains of comparable items. Web text often contains passages which are meant to be interpreted as lists but are parsed as single sentences. Email signatures in particular contain these structures, in the form of contact information: the different contact information items are labeled as <em>list</em>; the key-value pair relations are labeled as <em>appos</em>.</p>

<div class="sd-parse">
Steve Jones Phone: 555-9814 Email: jones@abc.edf
name(Jones-2, Steve-1)
list(Jones-2, Phone:-3)
list(Jones-2, Email:-5)
appos(Phone:-3, 555-9814-4)
appos(Email:-5, jones@abc.edf-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/list.md" target="#">edit list</a></p>

<h2 id="mark-marker">mark: marker</h2>

<p>A marker is the word introducing a finite clause subordinate to
another clause. For a complement clause, this will typically be “that”
or “whether”. For an adverbial clause, the marker is typically a
preposition like “while” or “although”. The mark is a dependent of the
subordinate clause head.</p>

<div class="sd-parse">
Forces engaged in fighting after insurgents attacked
mark(attacked, after)
</div>

<div class="sd-parse">
He says that you like to swim
mark(swim, that)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/mark.md" target="#">edit mark</a></p>

<h2 id="mwe-multi-word-expression">mwe: multi-word expression</h2>

<p>The multi-word expression (modifier) relation is one of the three relations for compounding. 
It used for certain fixed grammaticized expressions with function words that behave like a single function word.</p>

<div class="sd-parse">
I like dogs as well as cats
mwe(well-5, as-4)
mwe(well-5, as-6)
</div>

<div class="sd-parse">
He cried because of you
mwe(of, because)
</div>

<div class="sd-parse">
Je préfère prendre un dessert plutôt qu' une entrée. \n I prefer getting a dessert rather than an appetizer
mwe(plutôt, qu')
</div>

<p>We are still developing conventions for headship in an mwe. At the moment, practice is a combination of choosing the main word that would be the head on an attempted analytical analysis, such as for <i>as well as</i> and simply choosing the leftmost word as head.</p>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/mwe.md" target="#">edit mwe</a></p>

<h2 id="name">name</h2>

<p><em>name</em> is one of the three relations for compounding in USD. It is used for proper nouns constituted of multiple nominal elements. For example, <em>name</em> would be used between the words of “Hillary Rodham Clinton” or “Carl XVI Gustaf” but not to replace the usual relations in a phrasal or clausal name like “The Lord of the Rings” or “The king of Sweden”.</p>

<div class="sd-parse">
Carl XVI Gustaf
name(Gustaf-3, Carl-1)
name(Gustaf-3, XVI-2)
</div>

<p>But regular syntactic relations in:</p>

<div class="sd-parse">
The king of Sweden
det(king-2, The-1)
nmod(king-2, Sweden-4)
case(Sweden-4, of-3)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/name.md" target="#">edit name</a></p>

<h2 id="ncmod-nominalized-clause-modifier">ncmod: nominalized clause modifier</h2>

<p>The <em>ncmod</em> relation is parallel to the <em>nmod</em> relation, but following the principle that dependencies do mark where new
clauses are introduced, we use <em>ncmod</em> for nominalized clause modifiers (of a NP or a VP).</p>

<div class="sd-parse">
They heard about you missing classes
ncmod(heard, missing)
</div>

<div class="sd-parse">
We have no information on whether users are at risk
ncmod(information, risk)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/ncmod.md" target="#">edit ncmod</a></p>

<h2 id="neg-negation-modifier">neg: negation modifier</h2>

<p>The negation modifier is the relation between a negation word and the
word it modifies.</p>

<div class="sd-parse">
Bill is not a scientist
neg(scientist, not)
</div>

<div class="sd-parse">
Bill does n't drive
neg(drive, n't)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/neg.md" target="#">edit neg</a></p>

<h2 id="nfincl-non-finite-clause">nfincl: non-finite clause</h2>

<p>The <em>nfincl</em> relation stands for “non-finite clause” and is used for participial and infinitival modifiers.</p>

<div class="sd-parse">
Levi's based in San Francisco produces jeans.
nfincl(Levi's-1, based-2)
</div>

<div class="sd-parse">
Bill essaya de tirer démontrant son incompétence \n Bill tried to shoot demonstrating his incompetence
nfincl(tirer-4, démontrant-5)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/nfincl.md" target="#">edit nfincl</a></p>

<h2 id="nmod-nominal-modifier">nmod: nominal modifier</h2>

<p>The <em>nmod</em> relation is used for nominal modifiers. In general, <em>nmod</em> expresses some form of oblique or adjunct relation that can be further specified by the <em>case</em>.  In conjunction with the <em>case</em> relation, it provides a uniform analysis for:</p>

<ul>
  <li>the possessive alternation:</li>
</ul>

<div class="sd-parse">
the Chair 's office
det(Chair-2, the-1)
nmod(office-4, Chair-2)
case(Chair-2, 's-3)
</div>

<div class="sd-parse">
the office of the Chair
det(office-2, the-1)
nmod(office-2, Chair-5)
case(Chair-5, of-3)
det(Chair-5, the-4)
</div>

<ul>
  <li>variant forms with case, a preposition or a postposition, as in Finnish for example:</li>
</ul>

<div class="sd-parse">
etsiä ilman johtolankaa \n to_search without clue.PARTITIVE
nmod(etsiä, johtolankaa)
case(johtolankaa, ilman)
</div>

<div class="sd-parse">
etsiä taskulampun kanssa \n to_search torch.GENITIVE with
nmod(etsiä, taskulampun)
case(taskulampun, kanssa)
</div>

<div class="sd-parse">
etsiä johtolangatta \n to_search clue.ABESSIVE
nmod(etsiä, johtolangatta)
</div>

<ul>
  <li>the dative alternation where the prepositional construction gets a similar analysis to the double object construction:</li>
</ul>

<div class="sd-parse">
give the children the toys
dobj(give, toys)
iobj(give, children)
</div>

<div class="sd-parse">
give the toys to the children
dobj(give, toys)
nmod(give, children)
case(children, to)
</div>

<div class="sd-parse">
donner les_jouets aux enfants \n give the_toys to_the children
dobj(donner-1, les_jouets-2)
nmod(donner-1, enfants-4)
case(enfants-4, aux-3)
</div>

<p><em>nmod</em> is also used for temporal nominal modifiers:</p>

<div class="sd-parse">
Last night , I swam in the pool
nmod(swam, night)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/nmod.md" target="#">edit nmod</a></p>

<h2 id="nsubj-nominal-subject">nsubj: nominal subject</h2>

<p>A nominal subject is a noun phrase which is the syntactic subject of a
clause. The governor of this relation might not always be a verb: when
the verb is a copular verb, the root of the clause is the complement
of the copular verb, which can be an adjective or noun.</p>

<div class="sd-parse">
Clinton defeated Dole
nsubj(defeated, Clinton)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/nsubj.md" target="#">edit nsubj</a></p>

<h2 id="nsubjpass-passive-nominal-subject">nsubjpass: passive nominal subject</h2>

<p>A passive nominal subject is a noun phrase which is the syntactic
subject of a passive clause.</p>

<div class="sd-parse">
Dole was defeated by Clinton
nsubjpass(defeated, Dole)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/nsubjpass.md" target="#">edit nsubjpass</a></p>

<h2 id="nummod-numeric-modifier">nummod: numeric modifier</h2>

<p>A numeric modifier of a noun is any number phrase that serves to
modify the meaning of the noun with a quantity.</p>

<div class="sd-parse">
Sam ate 3 sheep
nummod(sheep, 3)
</div>

<div class="sd-parse">
Sam spent forty dollars
nummod(dollars, forty)
</div>

<div class="sd-parse">
Sam spent $ 40
nummod($, 40)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/nummod.md" target="#">edit nummod</a></p>

<h2 id="parataxis-parataxis">parataxis: parataxis</h2>

<p>The parataxis relation (from Greek for “place side by side”) is a
relation between the main verb of a clause and other sentential
elements, such as a sentential parenthetical, a clause after a “:” or
a “;”, or two sentences placed side by side without any explicit
coordination or subordination.</p>

<div class="sd-parse">
The guy , John said , left early in the morning
parataxis(left, said)
</div>

<div class="sd-parse">
Let 's face it we 're annoyed
parataxis(Let, annoyed)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/parataxis.md" target="#">edit parataxis</a></p>

<h2 id="punct-punctuation">punct: punctuation</h2>

<p>This is used for any piece of punctuation in a clause, if punctuation
is being retained in the typed dependencies. By default, punctuation
is not retained in the output.</p>

<div class="sd-parse">
Go home !
punct(Go, !)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/punct.md" target="#">edit punct</a></p>

<h2 id="relcl-relative-clause-modifier">relcl: relative clause modifier</h2>

<p>A relative clause modifier of an NP is a relative clause modifying the
NP.  The relation points from the head noun of the NP to the head of
the relative clause, normally a verb.</p>

<div class="sd-parse">
I saw the man you love
relcl(man, love)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/relcl.md" target="#">edit relcl</a></p>

<h2 id="remnant-remnant-in-ellipsis">remnant: remnant in ellipsis</h2>

<p>The <em>remnant</em> relation is used to provide a satisfactory treatment of ellipsis (in
the case of gapping and stripping, where a predicational or verbal
head gets elided). This is something that was lacking in earlier versions
of SD and provides a basis for being able to reconstruct dependencies
in the enhanced representation of SD. 
In particular, the goal was to achieve this <em>without</em> having to postulate empty nodes in the basic representation.</p>

<p>To develop motivation, consider first a sentence without ellipsis:</p>

<div class="sd-parse">
Marie went to Paris and Miriam went to Prague
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
cc(went-2, and-5)
nsubj(went-7, Miriam-6)
conj(went-2, went-7)
case(Prague-9, to-8)
nmod(went-7, Prague-9)
</div>

<p>The question is then how to treat: <em>Marie went to Paris and Miriam to Prague</em></p>

<div class="sd-parse">
Marie went to Paris and Miriam to Prague
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
cc(went-2, and-5)
case(Prague-8, to-7)
</div>

<p>One option would be to pretend that there is an empty verb and to have the final elements be dependents of it: <em>Marie went to Paris and Miriam ∅ to Prague</em>. This analysis has some appeal but also has some problems and at any rate stops the basic dependency graph from being simply a tree of dependencies over the words of a sentence. A second option is to simple promote the final elements and to have them as dependents of the main verb of the sentence (<em>went-2</em>) or of <em>root-0</em>. But then (in general) one loses the ability to successfully reconstruct the correct predicate-argument structure of the sentence from the basic dependency representation.</p>

<p>Therefore, USD adopts an analysis that notes that in ellipsis a <em>remnant</em> corresponds to a <em>correlate</em> in a preceding clause. The <em>remnant</em> relation connects each remnant to its correlate in the basic dependency representation. This is then a sufficient representation to reconstruct the predicate-argument sturcture in the enhanced representation. So, for this example, we have:</p>

<div class="sd-parse">
Marie went to Paris and Miriam to Prague
nsubj(went-2, Marie-1)
root(root-0, went-2)
nmod(went-2, Paris-4)
case(Paris-4, to-3)
cc(went-2, and-5)
remnant(Marie-1, Miriam-6)
case(Prague-8, to-7)
remnant(Paris-4, Prague-8)
</div>

<p>Even in the more complex example below, the <em>remnant</em>
relations enable us to correctly retrieve the subjects and objects in
the clauses with an elided verb.</p>

<div class="sd-parse">
John won bronze , Mary silver , and Sandy gold
nsubj(won-2, John-1)
dobj(won-2, bronze-3)
remnant(John-1, Mary-5)
remnant(Mary-5, Sandy-9)
remnant(bronze-3, silver-6)
remnant(silver-6, gold-10)
</div>

<p>Note in particular that (unlike for <em>conj</em>), <em>remnant</em> uses a chaining analysis where each subsequent remnant depends on the immediately preceding remnant/correlate. The reason for this is that otherwise in a sentence with 2 or more chained ellipses the dependency structure would no longer track which remnants go together. It would become impossible to determine whether Mary won silver and Sandy gold, or Mary won gold and Sandy silver.</p>

<p>The <em>remnant</em> relation is used when no predicational material is present. In contrast, in right-node-raising (RNR) and VP-ellipsis constructions in which some kind of predicational or verbal material is still present, the <em>remnant</em> relation is not used. In RNR, the verbs
are coordinated and the object is a <em>dobj</em> of the first verb:</p>

<div class="sd-parse">
John bought and ate an apple
nsubj(bought-2, John-1)
cc(bought-2, and-3)
conj(bought-2, ate-4)
det(apple-6, an-5)
dobj(bought-2, apple-6)
</div>

<p>In VP-ellipsis, we keep the auxiliary as the head, as shown below:</p>

<div class="sd-parse">
John will win gold and Mary will too
nsubj(win-3, John-1)
aux(win-3, will-2)
dobj(win-3, gold-4)
cc(win-3, and-5)
conj(win-3, will-7)
nsubj(will-7, Mary-6)
advmod(will-7, too-8)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/remnant.md" target="#">edit remnant</a></p>

<h2 id="reparandum-overridden-disfluency">reparandum: overridden disfluency</h2>

<p>[TODO complete description]</p>

<p>We use <em>reparandum</em> to indicate disfluencies overridden in a speech
repair.</p>

<div class="sd-parse">
Go to the righ- to the left .
nmod(Go-1, left-7)
reparandum(left-7, righ-)
case(righ-, to-2)
det(righ-, the-3)
case(left-7, to-5)
det(left-7, the-6)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/reparandum.md" target="#">edit reparandum</a></p>

<h2 id="root-root">root: root</h2>

<p>The root grammatical relation points to the root of the sentence. A
fake node “ROOT” is used as the governor. The ROOT node is indexed
with “0”, since the indexation of real words in the sentence starts at
1.</p>

<div class="sd-parse">
ROOT I love French fries .
root(ROOT, love)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/root.md" target="#">edit root</a></p>

<h2 id="vocative-vocative">vocative: vocative</h2>

<p>The <em>vocative</em> relation is used to mark dialogue participant addressed in text (common in emails and newsgroup postings). The relation links the addressee’s name to its host sentence.</p>

<div class="sd-parse">
Guys , take it easy!
vocative(take, Guys)
</div>

<div class="sd-parse">
Marie , comment vas - tu ?
vocative(vas, Marie)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/vocative.md" target="#">edit vocative</a></p>

<h2 id="xcomp-open-clausal-complement">xcomp: open clausal complement</h2>

<p>An open clausal complement (<em>xcomp</em>) of a verb or an adjective is a
predicative or clausal complement without its own subject. The
reference of the subject is necessarily determined by an argument
external to the xcomp (normally by the object of the next higher
clause, if there is one, or else by the subject of the next higher
clause. These complements are always non-finite, and they are
complements (arguments of the higher verb or adjective) rather than
adjuncts/modifiers, such as a purpose clause. The name <em>xcomp</em> is
borrowed from Lexical-Functional Grammar.</p>

<div class="sd-parse">
He says that you like to swim
xcomp(like, swim)
</div>

<div class="sd-parse">
Sue asked George to respond to her offer
xcomp(asked, respond)
</div>

<div class="sd-parse">
I consider him a fool
xcomp(consider, fool)
</div>

<div class="sd-parse">
I consider him honest
xcomp(consider, honest)
</div>

<p><a href="https://github.com/universaldependencies/docs/edit/pages-source/_ud-dep/xcomp.md" target="#">edit xcomp</a></p>



<!-- "relation in other languages" links -->
<hr/>
























































































































































      </div>

<script type="text/javascript">
//    var bratLocation = 'http://weaver.nlplab.org/~brat/demo/v1.3';
    var bratLocation = 'http://weaver.nlplab.org/~brat/demo/master';
    head.js(
        // External libraries
        bratLocation + '/client/lib/jquery.min.js',
        bratLocation + '/client/lib/jquery.svg.min.js',
        bratLocation + '/client/lib/jquery.svgdom.min.js',
	bratLocation + '/client/lib/jquery-ui.min.js',

        // brat helper modules
        bratLocation + '/client/src/configuration.js',
        bratLocation + '/client/src/util.js',
        bratLocation + '/client/src/annotation_log.js',
        bratLocation + '/client/lib/webfont.js',
        // brat modules
        bratLocation + '/client/src/dispatcher.js',
        bratLocation + '/client/src/url_monitor.js',
        bratLocation + '/client/src/visualizer.js'
    );

    var webFontURLs = [
//        bratLocation + '/static/fonts/Astloch-Bold.ttf',
        bratLocation + '/static/fonts/PT_Sans-Caption-Web-Regular.ttf',
        bratLocation + '/static/fonts/Liberation_Sans-Regular.ttf'
    ];

    var collData = {
	'entity_types': [
// this is optional
        {
            'type': 'SPAN_DEFAULT',
            'bgColor': '#7fa2ff',
            'borderColor': 'darken'
        },
        {
            'type': 'token',
            'labels': [ '\u00A0\u00A0' ], // non-breaking space for empty
        },
        {
            'type': '-',
            'labels': [ '\u00A0\u00A0' ], // non-breaking space for empty
        }
	],
	'entity_attribute_types': [],
	'relation_types': [
// this is optional
//         {
//             'type': 'subj',
//             'labels': [ 'subj' ],
//             'dashArray': '3,3',
//             'color': 'green',
//             'args': [
//                 {
//                     'role': 'arg1',
//                     'targets': [ 'token' ]
//                 },
//                 {
//                     'role': 'arg2',
//                     'targets': [ 'token' ]
//                 }
//             ]
//         }
        ],
	'event_types': [],
    };

    var normalizeSpace = function(s) {
	s = s.replace(/^\s+/, '');
	s = s.replace(/\s+$/, '');
	s = s.replace(/\s\s+/g, ' ');
	return s;
    };

    var compactJSON = function(s) {
        // remove (some) space from JSON string, giving a visually
        // more compact (but equivalent and still pretty-printed)
        // version.

        if (s === undefined) {
            return s;
        }

	// replace any space with ' ' in non-nested curly brackets
	s = s.replace(/(\{[^\{\}\[\]]*\})/g, 
		      function(a, b) { return b.replace(/\s+/g, ' '); });
	// replace any space with ' ' in [] up to nesting depth 1
// 	s = s.replace(/(\[(?:[^\[\]\{\}]|\[[^\[\]\{\}]*\])*\])/g, 
// 		      function(a, b) { return b.replace(/\s+/g, ' '); });
	// actually, up to nesting depth 2
	s = s.replace(/(\[(?:[^\[\]\{\}]|\[(?:[^\[\]\{\}]|\[[^\[\]\{\}]*\])*\])*\])/g, 
		      function(a, b) { return b.replace(/\s+/g, ' '); });
	return s
    };

    var objectToString = function(data) {
	return compactJSON(JSON.stringify(data, undefined, '    '));
    };

    var parseToken = function(token) {
	// return [text, POS] for token encoded as "text/POS", or
	// [text, "token"] if no POS (/-separated string) is included.
	var text, POS;

	m = token.match(/((?:[^\\]|\\.)+)\/(.+)$/);
	if (!m) {
	    text = token, POS = 'token';
	} else {
	    text = m[1], POS = m[2];
	}

	// apply defined backslash escape sequences
	text = text.replace(/((?:[^\\]+|\\.)*?)\\n/g, '$1\n');

	// unescape backslash escapes in text and tag
	text = text.replace(/([^\\]*)\\(.)/g, '$1$2');
	POS = POS.replace(/([^\\]*)\\(.)/g, '$1$2');

	return [text, POS];
    };

    // helper for *parse functions
    var makeLogger = function(logElement) {
        return function(s) {
	    if (logElement === undefined) {
		console.log(s);
	    } else {
		logElement.val(logElement.val() + s + '\n');
	    }
	};
    };

    // parse .ann format textbound line (helper for parseAnn)
    var parseAnnTextbound = function(line, log) {
        // NOTE: space matched more liberally than in primary format
        m = line.match(/^(\S+)\s+(\S+)\s+(\d+\s+\d+(?:;\d+\s+\d+)*)\s+(.*)$/);

        if (!m) {
            log('failed to parse textbound: "'+line+'"');
            return null;
        }

        var id = m[1],
            type = m[2],
            spanstr = m[3],
            text = m[4];

        // multiple (start, end) spans separated by semicolons
        var spanarr = normalizeSpace(spanstr).split(';'),
            spans = [];
        for (var i=0; i<spanarr.length; i++) {
            m = spanarr[i].match(/^(\d+)\s+(\d+)$/);
            if (!m) {
                log('error parsing offsets: "'+line+'"');
                return null;
            }
            var start = m[1], end = m[2];
            start = parseInt(start, 10);
            end = parseInt(end, 10);
            if (isNaN(start) || isNaN(end) || end < start) {
                log('failed to parse offsets: "'+line+'"');
                return null;
            }
            spans.push([start, end]);
        }

        // TODO verify text

        return [id, type, spans];
    };

    // parse .ann format relation line (helper for parseAnn)
    var parseAnnRelation = function(line, log) {
        // NOTE: space matched more liberally than in primary format
        m = line.match(/^(\S+)\s+(\S+)\s+(\S+):(\S+)\s+(\S+):(\S+)\s*$/);

        if (!m) {
            log('failed to parse relation: "'+line+'"');
            return null;
        }

        var id = m[1],
            type = m[2],
            a1l = m[3],
            a1i = m[4],
            a2l = m[5],
            a2i = m[6];

        return [id, type, [ [a1l, a1i], [a2l, a2i] ] ];
    };

    // parse .ann format equiv line (helper for parseAnn)
    var parseAnnEquiv = function(line, log) {
        // NOTE: space matched more liberally than in primary format
        m = line.match(/^(\S+)\s+(\S+)\s+(.+?)\s*$/);

        if (!m) {
            log('failed to parse equiv: "'+line+'"');
            return null;
        }

        var id = m[1],
            type = m[2],
            argstr = m[3];
    
        var args = normalizeSpace(argstr).split(' ');

        return [id, type].concat(args);
    };

    // parse .ann format event line (helper for parseAnn)
    var parseAnnEvent = function(line, log) {
        // NOTE: space matched more liberally than in primary format
        m = line.match(/^(\S+)\s+(\S+):(\S+)(.*)$/);

        if (!m) {
            log('failed to parse event: "'+line+'"');
            return null;
        }

        var id = m[1],
            type = m[2],
            trigger = m[3],
            argstr = m[4];

        var args = [];
        if (!argstr.match(/^\s*$/)) {
            var argarr = normalizeSpace(argstr).split(' ');
            for (var i=0; i<argarr.length; i++) {
                m = argarr[i].match(/^(\S+):(\S+)$/);
                if (!m) {
                    log('failed to parse event args: "'+line+'"');
                    return null;
                }
                args.push([m[1], m[2]]);
            }
        }

        return [id, trigger, args];
    };

    // parse .ann format modifier line (helper for parseAnn)
    var parseAnnModifier = function(line, log) {
        // NOTE: space matched more liberally than in primary format
        m = line.match(/^(\S+)\s+(\S+)\s+(\S+)\s*$/);

        if (!m) {
            log('failed to parse modifier: "'+line+'"');
            return null;
        }

        var id = m[1],
            type = m[2],
            target = m[3];

        return [id, type, target];
    };

    // parse .ann format attribute line (helper for parseAnn)
    var parseAnnAttribute = function(line, log) {
        // NOTE: space matched more liberally than in primary format
        m = line.match(/^(\S+)\s+(\S+)\s+(\S+)(.*)$/);

        if (!m) {
            log('failed to parse attribute: "'+line+'"');
            return null;
        }

        var id = m[1],
            type = m[2],
            target = m[3],
            value = m[4];

        // support also older ("modifier") format w/o value
        if (value.match(/^\s*$/)) {
            value = true;
        }

        return [id, type, target, value];
    };

    // parse .ann format normalization line (helper for parseAnn)
    var parseAnnNormalization = function(line, log) {
        // TODO: implement parsing for normalization annotations
        log('normalization annotation parsing not implemented: "'+line+'"');
        return null;
    };

    // parse .ann format comment line (helper for parseAnn)
    var parseAnnComment = function(line, log) {
        // TODO: implement parsing for comment annotations
        log('comment annotation parsing not implemented: "'+line+'"');
        return null;
    };

    // parse .ann format, return brat document data format
    var parseAnn = function(ann, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = ann.split('\n');
        
	// first line is assumed to be the document text
	var document_text = lines[0];

        // parse lines after the first as .ann-formatted lines
        // (see e.g. http://brat.nlplab.org/standoff.html)
        var textbounds = [],
            relations = [],
            events = [],
            equivs = [],
            attributes = [],
            normalizations = [],
            comments = [],
            error = false;
        for (var i=1; i<lines.length; i++) {
            var line = lines[i];

            if (line.match(/^\s*$/)) {
                continue; // ignore empties
            }

            // annotation type determined by first character on line
            switch (line[0]) {
                case 'T': 
                    textbounds.push(parseAnnTextbound(line, log));
                    break;
                case 'R': 
                    relations.push(parseAnnRelation(line, log));
                    break;
                case 'E': 
                    events.push(parseAnnEvent(line, log));
                    break;
                case 'M': 
                    attributes.push(parseAnnModifier(line, log));
                    break;
                case 'A': 
                    attributes.push(parseAnnAttribute(line, log));
                    break;
                case 'N': 
                    normalizations.push(parseAnnNormalization(line, log));
                    break;
                case '*': 
                    equivs.push(parseAnnEquiv(line, log));
                    break;
                case '#': 
                    comments.push(parseAnnComment(line, log));
                    break;
                default:
                    log('failed to parse line: "'+line+'"');
                    error = true;
            }
        }

        // filter annotation lists for nulls or empties (marking parse failure),
        // setting error if found.
        var validAnnotation = function(ann) {
            if (ann !== null && ann.length != 0) {
                return true;
            } else {
                error = true; // NOTE: side-effect
                return false;
            }
        };
        textbounds = textbounds.filter(validAnnotation);
        relations = relations.filter(validAnnotation);
        events = events.filter(validAnnotation);
        equivs = equivs.filter(validAnnotation);
        attributes = attributes.filter(validAnnotation);
        normalizations = normalizations.filter(validAnnotation);
        comments = comments.filter(validAnnotation);

        log('.ann parse done, error = '+error);

        // split textbounds into entities and triggers, where any textbound
        // referenced from an event is a trigger, and everything else is an
        // entity.
        var entities = [], 
            triggers = [],
            isTrigger = {};
        for (var i=0; i<events.length; i++) {
            var triggerId = events[i][1];
            isTrigger[triggerId] = true;
        }
        for (var i=0; i<textbounds.length; i++) {
            var textboundId = textbounds[i][0];
            if (isTrigger[textboundId]) {
                 triggers.push(textbounds[i]);
            } else {
                 entities.push(textbounds[i]);
            }
        }

        return {
            'text': document_text,
            'entities': entities,
            'triggers': triggers,
            'relations': relations,
            'events': events,
            'equivs': equivs,
            'attributes': attributes,
            'normalizations': normalizations,
            'comments': comments,
            'error': error
        };
    };

    // parse SD format, return brat document data format
    var parseSd = function(sd, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = sd.split('\n');

	// first line is assumed to be sentence text
	var sentence_text = lines[0];
	sentence_text = normalizeSpace(sentence_text);

	// determine token offsets and construct spans ("entities")
	var tokens = sentence_text.split(' '),
            spans = [],
            offset = 0,
            error = false;
	sentence_text = '';
	for (var i=0; i<tokens.length; i++) {
	    var text_POS = parseToken(tokens[i]);
	    var text = text_POS[0], POS = text_POS[1];
	    var length = text.length;
	    if (!text.match(/^\s*$/)) { // skip space-only (e.g. newline)
		spans.push(['T'+(i+1), POS, [[offset, offset+length]]]);
		tokens[i] = text;
	    }
	    offset += length + 1;
	    sentence_text += text + ' ';
	}

	var tokenIndex = function(t) {
	    // accept two formats: indexed ('dog-1') and simple ('dog')
	    // TODO: consider case-insensitive implementation

	    // indexed match
	    var m = t.match(/^\s*(.*)-(\d+)\s*$/)	      
	    if (m) {
		var text = m[1], idx = m[2];
		// confirm match (SD indices are 1-based)
		idx = parseInt(idx, 10) - 1;
		if (tokens[idx] === text) {
		    return idx;
		} else {
		    // TODO consider skipping output, not necessarily an error
		    log('token text mismatch: "'+text+'" vs. "'+tokens[idx]+'"');
		}
		// fall through to allow simple match for e.g. 'il-2'
	    }

	    // simple match
	    var firstIdx = $.inArray(t, tokens);
	    if (firstIdx === -1) {
		return null;
	    } else {
		if ($.inArray(t, tokens, firstIdx+1) !== -1) {
		    log('warning: multiple occurrences of "'+t+'"');
		}
		return firstIdx;
	    }
	};

	// parse lines after the first as dependencies, construct relations
	var relations = [];
	for (var i=1; i<lines.length; i++) {
	    var line = lines[i];
	    line = normalizeSpace(line);
	    
	    if (line.match(/^\s*$/)) {
		continue; // ignore empties
	    }
	    
	    var m = line.match(/^(\S+)\s*\(\s*(\S+)\s*,\s*(\S+)\s*\)$/);
	    if (!m) {
		log('failed to parse: "'+line+'"');
		error = true;
		continue;
	    }
	    var type = m[1], from = m[2], to = m[3];
	    
	    // determine which tokens are referred to
	    var fromIdx = tokenIndex(from), toIdx = tokenIndex(to);
	    if (fromIdx === null || toIdx === null) {
		log('failed to find token: "'+line+'"');
		error = true;
		continue;
	    }
	    
	    relations.push([ 'R'+i, type, [ [ 'arg1', 'T'+(fromIdx+1) ], 
					    [ 'arg2', 'T'+(toIdx+1)   ] ] ]);
	}

	log('SD parse done: '+spans.length+' tokens, '+relations.length+' dependencies.');
          
	return {
	    'text': sentence_text,
	    'entities' : spans,
            'relations' : relations,
	    'error' : error
	};
    };

    // represents CoNLL-U token or word
    var ConllUElement = function(fields) {
        this.id = fields[0];
        this.form = fields[1];
        this.lemma = fields[2];
        this.cpostag = fields[3];
        this.postag = fields[4];
        this.feats = fields[5];
        this.head = fields[6];
        this.deprel = fields[7];
        this.deps = fields[8];
        this.misc = fields[9];
    };

    ConllUElement.prototype.validId = function(id) {
        return !!this.id.match(/^\d+(?:\.\d+)?$/);
    };

    ConllUElement.prototype.isWord = function() {
        // word iff lemma is not an underscore
        return this.lemma !== '_';
    };

    ConllUElement.prototype.isToken = function() {
        // token iff ID is an integer
        return !!this.id.match(/^[0-9]+$/);
    };

    // return list of (HEAD, DEPREL) pairs
    ConllUElement.prototype.dependencies = function() {
        var headDeps = [];
        if (this.head != '_') {
            headDeps.push([this.head, this.deprel]);
        }
        if (this.deps != '_') {
            var split = this.deps.split('|');
            for (var i=0; i<split.length; i++) {
                m = split[i].match(/^(.+?):(.*)$/);
                if (m) {
                    headDeps.push([m[1], m[2]]);
                } else {
                    console.log('internal error: headDeps() with invalid DEPS');
                }
            }
        }
        return headDeps;
    }

    ConllUElement.prototype.issues = function() {
        var issues = [];

        if (!this.validId(this.id)) {
            issues.push('ID "'+this.id+'" is not valid (integer or decimal)');
        }

        if (this.form === undefined || this.form.length == 0) {
            issues.push('missing FORM');
        }

        // if all remaining fields contain just an underscore, then this
        // is a (locally) valid token (assumed to have internal words)
        if (this.lemma == '_' && 
            this.cpostag == '_' &&
            this.postag == '_' &&
            this.feats == '_' &&
            this.head == '_' &&
            this.deprel == '_' &&
            this.deps == '_' &&
            this.misc == '_') {
            return issues;
        }
        // if we're here, assume non-token.

        // TODO: check LEMMA, CPOSTAG, etc.

        return issues;
    };

    // parse CoNLL-U format, return brat document data format
    var parseConllU = function(conll, log) {
	if (log === undefined) {
            log = makeLogger();
	}

        // TODO: allow multiple sentences

	var lines = conll.split('\n');

        // each line has the following format
        // (from http://universaldependencies.github.io/docs/format.html)
        // 1.  ID: Token counter. A number, starting at 1 for each new 
        //         sentence; may be a decimal number for words inside tokens.
        // 2.  FORM: Word form or punctuation symbol.
        // 3.  LEMMA: Lemma or stem of word form.
        // 4.  CPOSTAG: Google universal part-of-speech tag, drawn from the 
        //         Universal POS tag set.
        // 5.  POSTAG: Language-specific part-of-speech tag; underscore if not 
        //         available.
        // 6.  FEATS: List of morphological features (attribute-value pairs); 
        //         underscore if not available.
        // 7.  HEAD: Head of the current token, which is either a value of ID
        //         or zero (0).
        // 8.  DEPREL: Universal Stanford dependency relation to the HEAD 
        //         (root iff HEAD = 0) or a defined language-particular subtype
        //          of one.
        // 9.  DEPS: List of secondary dependencies (head-deprel pairs).
        // 10. MISC: Any other annotation.

        var elements = [],            
            error = false;
        for (var i=0; i<lines.length; i++) {
            var line = lines[i];

            if (line.length != 0 && line[0] === '#') {
                // comment line, skip.
                // TODO: confirm that comment precedes sentence, as "Comment
                // ... lines inside sentences ... are disallowed." (docs)
                continue;
            }

            line = line.replace(/\s$/, '');
            var fields = line.split(/\s+/);
            if (fields.length !== 10) {
                // TODO: better error handling
                log('expected 10 fields, got '+fields.length+': "'+line+'"');
		error = true;
		continue;
            }

            var element = new ConllUElement(fields);

            var issues = element.issues();
            for (var j=0; j<issues.length; j++) {
                log('parse error: '+issues[j]+' (line '+(i+1)+': "'+line+'")');
            }
            if (issues.length != 0) {
                error = true;
                continue;
            }

            elements.push(element);
        }

        // prepare by-id map, checking for duplicate IDs
        var elementById = {},
            filtered = [];
        for (var i=0; i<elements.length; i++) {
            var element = elements[i];
            if (elementById[element.id] === undefined) {
                elementById[element.id] = element;
                filtered.push(element);
            } else {
                log('error: non-unique ID "'+element.id+'"');
                error = true;
            }
        }
        elements = filtered;

        // TODO: check (and resolve?) ID references:
        // - HEAD corresponds to valid non-token
        // - all heads in DEPS correspond to valid non-tokens

        var dependencies = [];
        for (var i=0; i<elements.length; i++) {
            var element = elements[i];
            var headDeps = element.dependencies();
            for (var j=0; j<headDeps.length; j++) {
                dependencies.push([element.id, headDeps[j][0], headDeps[j][1]]);
            }
        }

        var words = elements.filter(function(e) { return e.isWord() });
        var tokens = elements.filter(function(e) { return e.isToken() });
        var wordText = words.map(function(w) { return w.form }).join(' ');
        var tokenText = tokens.map(function(w) { return w.form }).join(' ');
        var combinedText = wordText;
        if (wordText != tokenText) {
            combinedText += '\n' + tokenText;
        }

        var spans = [],
            offset = 0;
        for (var i=0; i<words.length; i++) {
            var length = words[i].form.length;
	    spans.push(['T'+words[i].id, words[i].cpostag, 
                           [[offset, offset+length]]]);
            offset += length + 1;
        }

        var relations = [];
        for (var i=0; i<dependencies.length; i++) {
            var dep = dependencies[i];
            relations.push(['R'+i, dep[2], 
                            [ [ 'arg1', 'T'+dep[1] ],
                              [ 'arg2', 'T'+dep[0] ] ] ]);
        }

        // TODO: provide visualization for LEMMA, POSTAG, FEATS and MISC.

	return {
	    'text': combinedText,
	    'entities': spans,
            'relations': relations,
	    'error' : error
	};
    }

    // parse CoNLL-X format, return brat document data format
    var parseConllX = function(conll, log) {
	if (log === undefined) {
            log = makeLogger();
	}
	var lines = conll.split('\n');

        // each line has the following format
        // (from https://code.google.com/p/clearparser/wiki/DataFormat):
        //
        //     ID: token counter, starting at 1 for each new sentence
        //     FORM: word form or punctuation symbol
        //     LEMMA: lemma or stem of word form
        //     POSTAG: fine-grained part-of-speech tag
        //     FEATS: extra features ('_' indicates no extra feature)
        //     HEAD: head ID of the current token
        //     DEPREL: dependency relation to the HEAD
        // 
        // (here, we will use ID, FORM, POSTAG, HEAD and DEPREL)
        var ids = [],
            forms = [],
            postags = [],
            heads = [],
            deprels = [],
            error = false;
        for (var i=0; i<lines.length; i++) {
            var line = lines[i];
            line = line.replace(/\s$/, '');
            var fields = line.split(/\s+/);
            //var fields = line.split(/\t/);
            if (fields.length === 8) {
                ids.push(fields[0]);
                forms.push(fields[1]);
                postags.push(fields[4]);
                heads.push(fields[6]);
                deprels.push(fields[7]);
            } else {
                // TODO: better error handling
                log('expected 8 fields, got '+fields.length+': "'+line+'"');
		error = true;
		continue;
            }
        }

	var spans = [],
            relations = [],
            offset = 0;
	for (i=0; i<ids.length; i++) {
	    var length = forms[i].length;
	    spans.push(['T'+ids[i], postags[i], [[offset, offset+length]]]);
            offset += length + 1;
	    // TODO: handle root
	    if (heads[0] === 0) {
                continue;
	    }
            relations.push(['R'+ids[i], deprels[i], 
			    [ [ 'arg1', 'T'+heads[i] ],
			      [ 'arg2', 'T'+ids[i] ] ] ]);
        }

        var text = forms.join(' ');

	return {
	    'text': text,
	    'entities' : spans,
            'relations' : relations,
	    'error' : error
	};
    };

    // from http://stackoverflow.com/a/2117523
    var random_guid = function() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    };

    // add prefix and suffix to all IDs in data, modifying data. If neither a prefix
    // nor suffix is provided, add a random GUID prefix.
    var reviseIds = function(data, prefix, suffix) {
        if (prefix === undefined) {
            prefix = '';
        }
        if (suffix === undefined) {
            suffix = '';
        }
        if (prefix === '' && suffix == '') {
            // no prefix or suffix defined: generate random GUID prefix
            prefix = random_guid() + '-';
        }

        // entities: entity ID only
	var entities = data['entities'] || [];
	for (var i=0; i<entities.length; i++) {
            entities[i][0] = prefix + entities[i][0] + suffix;
        }

        // triggers: trigger ID only
	var triggers = data['triggers'] || [];
	for (var i=0; i<triggers.length; i++) {
            triggers[i][0] = prefix + triggers[i][0] + suffix;
        }

        // relations: relation ID and argument IDs
        var relations = data['relations'] || [];
        for (var i=0; i<relations.length; i++) {
            relations[i][0] = prefix + relations[i][0] + suffix;
            var args = relations[i][2];
            for (var j=0; j<args.length; j++) {
                args[j][1] = prefix + args[j][1] + suffix;
            }
        }

        // events: event ID, trigger ID, and argument IDs
        var events = data['events'] || [];
        for (var i=0; i<events.length; i++) {
            events[i][0] = prefix + events[i][0] + suffix;
            events[i][1] = prefix + events[i][1] + suffix;
            var args = events[i][2];
            for (var j=0; j<args.length; j++) {
                args[j][1] = prefix + args[j][1] + suffix;
            }
        }

	// equivs: argument IDs only
        var equivs = data['equivs'] || [];
        for (var i=0; i<equivs.length; i++) {
            for (var j=2; j<equivs[i].length; j++) {
                equivs[i][j] = prefix + equivs[i][j] + suffix;
            }
        }

	// attributes: attribute ID and target ID
        var attributes = data['attributes'] || [];
        for (var i=0; i<attributes.length; i++) {
            attributes[i][0] = prefix + attributes[i][0] + suffix;
            attributes[i][2] = prefix + attributes[i][2] + suffix;
        }

        // normalizations: normalization ID and target ID
        var normalizations = data['normalizations'] || [];
        for (var i=0; i<normalizations.length; i++) {
            normalizations[i][0] = prefix + normalizations[i][0] + suffix;
            normalizations[i][2] = prefix + normalizations[i][2] + suffix;
        }

        // comments: target ID only(!)
        var comments = data['comments'] || [];
        for (var i=0; i<comments.length; i++) {
            comments[i][0] = prefix + comments[i][0] + suffix;
        }

        return data;
    };

    var embeddedIdSeq = 1;

    var embedAnnotation = function(elem, parse, data, options) {
        // special case for supporting simple "~~~ sdparse [...] ~~~" 
        // syntax: if elem has a <pre> parent, add "embedding" class
        // to the <pre> so we can avoid margins etc. on the <pre>.
        elem.parent('pre').addClass('embedding');	

	// store sequence number for reference resolution
	elem.attr('embeddedSequenceNum', embeddedIdSeq);

	var eId = 'embedded-' + embeddedIdSeq++,
            inputTabId = eId + '-2',
            bratTabId = eId + '-3',
            infoTabId = eId + '-4';

	// visualization and related data elements
	var visDiv = $('<div id="'+eId+'-vis"></div>');
	var tabDiv = $('<div id="'+eId+'-tabs"></div>');
	var shDiv  = $('<div id="'+eId+'-sh" class="show-hide-div"></div>');
	var showHideButton = $('<button id="'+eId+'-toggle" '+
			       'class="show-hide-toggle">hide</button>');
	shDiv.append(showHideButton);

	var inputArea = $('<textarea id="'+eId+'-in" ' +
			  'class="embedded-brat-data"></textarea>');
	var bratArea = $('<textarea id="'+eId+'-brat" disabled="disabled" ' +
			 'class="embedded-brat-data"></textarea>');
	var logArea = $('<textarea id="'+eId+'-log" disabled="disabled" ' +
			'class="embedded-brat-data"></textarea>');

	// initialize parse function, falling back to SD as default
        // TODO: reconsider default
	if (parse === undefined) {
	    parse = parseSd;
	}

	// initialize data, defaulting to original element text
	if (data === undefined) {
	    data = elem.text();
	}
	data = normalizeSpace(data);    // TODO isn't this harmful for .ann?
	var parsed = parse(data, makeLogger(logArea));
        parsed = reviseIds(parsed, eId + '-');
	inputArea.text(data);
	bratArea.text(objectToString(parsed));

        // initialize options, falling back to attributes as defaults
        if (options === undefined) {
            options = {};
        }
        $.each(elem[0].attributes, function(idx) {
            var name = this.name;
            var value = this.value;
            // ignore standard attributes and options provided by caller
            var standardAttr = ['id', 'class', 'embeddedsequencenum'];
            if ($.inArray(name.toLowerCase(), standardAttr) === -1 &&
                options[name] === undefined) {
                options[name] = value;
            }
	});
				      
	// build top-level structure
	elem.empty();
	// tab headers (li+a)
	tabDiv.append([
		       '<div id="'+eId+'">',
		       '  <ul>',
		       '    <li><a href="#'+inputTabId+'">input</a></li>',
		       '    <li><a href="#'+bratTabId+'">brat</a></li>',
		       '    <li><a href="#'+infoTabId+'">info</a></li>',
		       '  </ul>',
		       '</div>'
		       ].join('\n'));
	// tab content (divs)
	var inputTab   = $('<div id="'+inputTabId+'"></div>'),
            bratTab = $('<div id="'+bratTabId+'"></div>'),
            logTab  = $('<div id="'+infoTabId+'"></div>');
	inputTab.append(inputArea);
	bratTab.append(bratArea);
	logTab.append(logArea);

	// add content to top-level element, turn into jQuery-ui tabs
	tabDiv.append(inputTab, bratTab, logTab);
	elem.append(shDiv, tabDiv, visDiv);
	tabDiv.tabs();
	var shVisible = 0;
	var setShToggleText = function() {
	    $('span', showHideButton).text(shVisible ? 'hide' : 'edit');
	}
	tabDiv.hide(); // TODO make optional (control e.g. using class)
        showHideButton.button().click(function(ev) {
	   tabDiv.toggle('blind');
	   shVisible = !shVisible;
	   setShToggleText();
	});
	setShToggleText();

        // only show tabs / tab visibility control if set in options
        if (options && !options.tabs) {
            showHideButton.hide();
            tabDiv.hide();
        }

	// initialize brat visualization
        var dispatcher = Util.embed(eId+'-vis',
          $.extend({'collection': null}, collData),
          $.extend({}, parsed), webFontURLs);

	// hook everything up
        var renderError = function() {
            bratArea.css({'border': '2px solid red'});
        };
        dispatcher.on('renderError: Fatal', renderError);

        var inputHandler = function() {
            var parsed, parse_error = false;

	    logArea.val(''); // clear log

            try {
                parsed = parse(inputArea.val(), makeLogger(logArea));
                parsed = reviseIds(parsed, embeddedIdSeq + '-');
		parse_error = parsed.error;
            } catch (e) {
		console.log(e);
		parse_error = true;
            }

	    // console.log(parse_error);

	    if (!parse_error) {
                inputArea.css({'border': '2px inset'});
	    } else {
                inputArea.css({'border': '2px solid red'});
                return;
	    }
    
	    bratArea.text(objectToString(parsed));

            try {
                dispatcher.post('requestRenderData', [$.extend({}, parsed)]);
                bratArea.css({'border': '2px inset'});
            } catch(e) {
		console.log('requestRenderData error:', e);
		logArea.append('requestRenderData error: '+e);
                bratArea.css({'border': '2px solid red'});
            }
        };
        inputArea.bind('propertychange keyup input paste', inputHandler);
    };

    var resolveEmbeddedReference = function(elem, data) {
	var refId = elem.attr('href'),
	    refElem = $(refId);
	
	if (refElem === undefined) {
	    console.log('Failed to resolve reference to', refId, 'for', elem);
	    return;
	}

	var refSeq = refElem.attr('embeddedSequenceNum');
	if (refSeq === undefined) {
	    console.log('no embeddedSequenceNum for', refElem);
	    return;
	}

	var origText = elem.text();
	var resolvedText = origText.replace(/\#/, refSeq);
	if (origText === resolvedText) {
	    console.log('failed replace in text', origText, 'for', elem);
	    return;
	}

	elem.text(resolvedText);
    };

    // class attribute values that trigger parsing using parseSd
    var parseSdClasses = [
        '.sd-parse',
        '.language-sdparse'
    ];

    // class attribute values that trigger parsing using parseConllX
    var parseConllXClasses = [
        '.conllx-parse',
        '.language-conllx',
    ];

    // class attribute values that trigger parsing using parseConllU
    var parseConllUClasses = [
        '.conllu-parse',
        '.language-conllu',
    ];

    var embedBratVisualizations = function() {
        // generate embedded visualizations: call embedAnnotation
	// for elements with "sd-parse" class (or variant).
        $(parseSdClasses.join(',')).each(function(idx) {
            embedAnnotation($(this), parseSd);
	});

        // repeat for elements with "conllx-parse" class (or variant), etc.
        $(parseConllXClasses.join(',')).each(function(idx) {
            embedAnnotation($(this), parseConllX);
	});

        $(parseConllUClasses.join(',')).each(function(idx) {
            embedAnnotation($(this), parseConllU);
	});

        $('.ann-annotation').each(function(idx) {
            embedAnnotation($(this), parseAnn);
	});

	// resolve references (e.g. "Figure #" -> "Figure 1"): call
	// resolveEmbeddedReference for elements with "embed-ref" class.
	$('.embed-ref').each(function(idx) {
            resolveEmbeddedReference($(this));
	});
    };

    head.ready(function() {
	// just call this in head.ready()
	embedBratVisualizations();
    });
</script>


      <div id="footer">
          <p class="footer-text">embedded brat &copy; 2010-2014 the <a href="http://brat.nlplab.org/about.html" style="color:gray">brat contributors</a></p>
      </div>
    </div>
  </body>
</html>
